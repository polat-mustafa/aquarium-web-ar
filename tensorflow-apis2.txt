Layers / Inputs
tf.layers.inputLayer (args) functionSource
An input layer is an entry point into a tf.LayersModel.

InputLayer is generated automatically for tf.Sequential models by specifying the inputshape or batchInputShape for the first layer. It should not be specified explicitly. However, it can be useful sometimes, e.g., when constructing a sequential model from a subset of another sequential model's layers. Like the code snippet below shows.

// Define a model which simply adds two inputs.
const model1 = tf.sequential();
model1.add(tf.layers.dense({inputShape: [4], units: 3, activation: 'relu'}));
model1.add(tf.layers.dense({units: 1, activation: 'sigmoid'}));
model1.summary();
model1.predict(tf.zeros([1, 4])).print();

// Construct another model, reusing the second layer of `model1` while
// not using the first layer of `model1`. Note that you cannot add the second
// layer of `model` directly as the first layer of the new sequential model,
// because doing so will lead to an error related to the fact that the layer
// is not an input layer. Instead, you need to create an `inputLayer` and add
// it to the new sequential model before adding the reused layer.
const model2 = tf.sequential();
// Use an inputShape that matches the input shape of `model1`'s second
// layer.
model2.add(tf.layers.inputLayer({inputShape: [3]}));
model2.add(model1.layers[1]);
model2.summary();
model2.predict(tf.zeros([1, 3])).print();
EditRun
Parameters:
args (Object)
inputShape ((null | number)[]) Input shape, not including the batch axis.
batchSize (number) Optional input batch size (integer or null).
batchInputShape ((null | number)[]) Batch input shape, including the batch axis.
dtype ('float32'|'int32'|'bool'|'complex64'|'string') Datatype of the input.
sparse (boolean) Whether the placeholder created is meant to be sparse.
name (string) Name of the layer.
Returns: InputLayer
Layers / Padding
tf.layers.zeroPadding2d (args?) functionSource
Zero-padding layer for 2D input (e.g., image).

This layer can add rows and columns of zeros at the top, bottom, left and right side of an image tensor.

Input shape: 4D tensor with shape:

If dataFormat is "channelsLast": [batch, rows, cols, channels]
If data_format is "channels_first": [batch, channels, rows, cols].
Output shape: 4D with shape:

If dataFormat is "channelsLast": [batch, paddedRows, paddedCols, channels] - If dataFormat is "channelsFirst": [batch, channels, paddedRows, paddedCols].
Parameters:
args (Object) Optional
padding (number|[number, number]|[[number, number], [number, number]]) Integer, or Array of 2 integers, or Array of 2 Arrays, each of which is an Array of 2 integers.
If integer, the same symmetric padding is applied to width and height.
If Array of 2 integers, interpreted as two different symmetric values for height and width: [symmetricHeightPad, symmetricWidthPad].
If Array of 2 Arrays, interpreted as: [[topPad, bottomPad], [leftPad, rightPad]].
dataFormat ('channelsFirst'|'channelsLast') One of 'channelsLast' (default) and 'channelsFirst'.
The ordering of the dimensions in the inputs. channelsLast corresponds to inputs with shape [batch, height, width, channels] while channelsFirst corresponds to inputs with shape [batch, channels, height, width].

inputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
batchInputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
batchSize (number) If inputShape is specified and batchInputShape is not specified, batchSize is used to construct the batchInputShape: [batchSize, ...inputShape]
dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data-type for this layer. Defaults to 'float32'. This argument is only applicable to input layers (the first layer of a model).
name (string) Name for this layer.
trainable (boolean) Whether the weights of this layer are updatable by fit. Defaults to true.
weights (tf.Tensor[]) Initial weight values of the layer.
inputDType ('float32'|'int32'|'bool'|'complex64'|'string') Legacy support. Do not use for new code.
Returns: ZeroPadding2D
Layers / Noise
tf.layers.alphaDropout (args) functionSource
Applies Alpha Dropout to the input.

As it is a regularization layer, it is only active at training time.

Alpha Dropout is a Dropout that keeps mean and variance of inputs to their original values, in order to ensure the self-normalizing property even after this dropout. Alpha Dropout fits well to Scaled Exponential Linear Units by randomly setting activations to the negative saturation value.

Arguments:

rate: float, drop probability (as with Dropout). The multiplicative noise will have standard deviation sqrt(rate / (1 - rate)).
noise_shape: A 1-D Tensor of type int32, representing the shape for randomly generated keep/drop flags.
Input shape: Arbitrary. Use the keyword argument inputShape (tuple of integers, does not include the samples axis) when using this layer as the first layer in a model.

Output shape: Same shape as input.

References:

Self-Normalizing Neural Networks
Parameters:
args (Object)
rate (number) drop probability.
noiseShape ((null | number)[]) A 1-D Tensor of type int32, representing the shape for randomly generated keep/drop flags.
inputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
batchInputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
batchSize (number) If inputShape is specified and batchInputShape is not specified, batchSize is used to construct the batchInputShape: [batchSize, ...inputShape]
dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data-type for this layer. Defaults to 'float32'. This argument is only applicable to input layers (the first layer of a model).
name (string) Name for this layer.
trainable (boolean) Whether the weights of this layer are updatable by fit. Defaults to true.
weights (tf.Tensor[]) Initial weight values of the layer.
inputDType ('float32'|'int32'|'bool'|'complex64'|'string') Legacy support. Do not use for new code.
Returns: AlphaDropout
tf.layers.gaussianDropout (args) functionSource
Apply multiplicative 1-centered Gaussian noise.

As it is a regularization layer, it is only active at training time.

Arguments:

rate: float, drop probability (as with Dropout). The multiplicative noise will have standard deviation sqrt(rate / (1 - rate)).
Input shape: Arbitrary. Use the keyword argument inputShape (tuple of integers, does not include the samples axis) when using this layer as the first layer in a model.

Output shape: Same shape as input.

References:

Dropout: A Simple Way to Prevent Neural Networks from Overfitting
Parameters:
args (Object)
rate (number) drop probability.
inputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
batchInputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
batchSize (number) If inputShape is specified and batchInputShape is not specified, batchSize is used to construct the batchInputShape: [batchSize, ...inputShape]
dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data-type for this layer. Defaults to 'float32'. This argument is only applicable to input layers (the first layer of a model).
name (string) Name for this layer.
trainable (boolean) Whether the weights of this layer are updatable by fit. Defaults to true.
weights (tf.Tensor[]) Initial weight values of the layer.
inputDType ('float32'|'int32'|'bool'|'complex64'|'string') Legacy support. Do not use for new code.
Returns: GaussianDropout
tf.layers.gaussianNoise (args) functionSource
Apply additive zero-centered Gaussian noise.

As it is a regularization layer, it is only active at training time.

This is useful to mitigate overfitting (you could see it as a form of random data augmentation). Gaussian Noise (GS) is a natural choice as corruption process for real valued inputs.

Arguments
stddev: float, standard deviation of the noise distribution.

Input shape
Arbitrary. Use the keyword argument input_shape (tuple of integers, does not include the samples axis) when using this layer as the first layer in a model.

Output shape
Same shape as input.

Parameters:
args (Object)
stddev (number) Standard Deviation.
inputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
batchInputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
batchSize (number) If inputShape is specified and batchInputShape is not specified, batchSize is used to construct the batchInputShape: [batchSize, ...inputShape]
dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data-type for this layer. Defaults to 'float32'. This argument is only applicable to input layers (the first layer of a model).
name (string) Name for this layer.
trainable (boolean) Whether the weights of this layer are updatable by fit. Defaults to true.
weights (tf.Tensor[]) Initial weight values of the layer.
inputDType ('float32'|'int32'|'bool'|'complex64'|'string') Legacy support. Do not use for new code.
Returns: GaussianNoise
Layers / Mask
tf.layers.masking (args?) functionSource
Masks a sequence by using a mask value to skip timesteps.

If all features for a given sample timestep are equal to mask_value, then the sample timestep will be masked (skipped) in all downstream layers (as long as they support masking).

If any downstream layer does not support masking yet receives such an input mask, an exception will be raised.

Arguments:

maskValue: Either None or mask value to skip.
Input shape: Arbitrary. Use the keyword argument inputShape (tuple of integers, does not include the samples axis) when using this layer as the first layer in a model.

Output shape: Same shape as input.

Parameters:
args (Object) Optional
maskValue (number) Masking Value. Defaults to 0.0.
inputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
batchInputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
batchSize (number) If inputShape is specified and batchInputShape is not specified, batchSize is used to construct the batchInputShape: [batchSize, ...inputShape]
dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data-type for this layer. Defaults to 'float32'. This argument is only applicable to input layers (the first layer of a model).
name (string) Name for this layer.
trainable (boolean) Whether the weights of this layer are updatable by fit. Defaults to true.
weights (tf.Tensor[]) Initial weight values of the layer.
inputDType ('float32'|'int32'|'bool'|'complex64'|'string') Legacy support. Do not use for new code.
Returns: Masking
Layers / Rescaling
tf.layers.rescaling (args?) functionSource
A preprocessing layer which rescales input values to a new range.

This layer rescales every value of an input (often an image) by multiplying by scale and adding offset.

For instance:

To rescale an input in the [0, 255] range to be in the [0, 1] range, you would pass scale=1/255.
To rescale an input in the [0, 255] range to be in the [-1, 1] range, you would pass scale=1./127.5, offset=-1. The rescaling is applied both during training and inference. Inputs can be of integer or floating point dtype, and by default the layer will output floats.
Arguments:

scale: Float, the scale to apply to the inputs.
offset: Float, the offset to apply to the inputs.
Input shape: Arbitrary.

Output shape: Same as input.

Parameters:
args (Object) Optional
scale (number)
offset (number)
inputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
batchInputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
batchSize (number) If inputShape is specified and batchInputShape is not specified, batchSize is used to construct the batchInputShape: [batchSize, ...inputShape]
dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data-type for this layer. Defaults to 'float32'. This argument is only applicable to input layers (the first layer of a model).
name (string) Name for this layer.
trainable (boolean) Whether the weights of this layer are updatable by fit. Defaults to true.
weights (tf.Tensor[]) Initial weight values of the layer.
inputDType ('float32'|'int32'|'bool'|'complex64'|'string') Legacy support. Do not use for new code.
Returns: Rescaling
Layers / CenterCrop
tf.layers.centerCrop (args?) functionSource
A preprocessing layer which center crops images.

This layers crops the central portion of the images to a target size. If an image is smaller than the target size, it will be resized and cropped so as to return the largest possible window in the image that matches the target aspect ratio.

Input pixel values can be of any range (e.g. [0., 1.) or [0, 255]) and of integer or floating point dtype.

If the input height/width is even and the target height/width is odd (or inversely), the input image is left-padded by 1 pixel.

Arguments: height: Integer, the height of the output shape. width: Integer, the width of the output shape.

Input shape: 3D (unbatched) or 4D (batched) tensor with shape: (..., height, width, channels), in channelsLast format.

Output shape: 3D (unbatched) or 4D (batched) tensor with shape: (..., targetHeight, targetWidth, channels).

Parameters:
args (Object) Optional
height (number)
width (number)
inputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
batchInputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
batchSize (number) If inputShape is specified and batchInputShape is not specified, batchSize is used to construct the batchInputShape: [batchSize, ...inputShape]
dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data-type for this layer. Defaults to 'float32'. This argument is only applicable to input layers (the first layer of a model).
name (string) Name for this layer.
trainable (boolean) Whether the weights of this layer are updatable by fit. Defaults to true.
weights (tf.Tensor[]) Initial weight values of the layer.
inputDType ('float32'|'int32'|'bool'|'complex64'|'string') Legacy support. Do not use for new code.
Returns: CenterCrop
Layers / Resizing
tf.layers.resizing (args?) functionSource
A preprocessing layer which resizes images. This layer resizes an image input to a target height and width. The input should be a 4D (batched) or 3D (unbatched) tensor in "channels_last" format. Input pixel values can be of any range (e.g. [0., 1.) or [0, 255]) and of interger or floating point dtype. By default, the layer will output floats.

Arguments:

height: number, the height for the output tensor.
width: number, the width for the output tensor.
interpolation: string, the method for image resizing interpolation.
cropToAspectRatio: boolean, whether to keep image aspect ratio.
Input shape: Arbitrary.

Output shape: height, width, num channels.

Parameters:
args (Object) Optional
height (number)
width (number)
interpolation (InterpolationType)
cropToAspectRatio (boolean)
inputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
batchInputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
batchSize (number) If inputShape is specified and batchInputShape is not specified, batchSize is used to construct the batchInputShape: [batchSize, ...inputShape]
dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data-type for this layer. Defaults to 'float32'. This argument is only applicable to input layers (the first layer of a model).
name (string) Name for this layer.
trainable (boolean) Whether the weights of this layer are updatable by fit. Defaults to true.
weights (tf.Tensor[]) Initial weight values of the layer.
inputDType ('float32'|'int32'|'bool'|'complex64'|'string') Legacy support. Do not use for new code.
Returns: Resizing
Layers / CategoryEncoding
tf.layers.categoryEncoding (args) functionSource
A preprocessing layer which encodes integer features.

This layer provides options for condensing data into a categorical encoding when the total number of tokens are known in advance. It accepts integer values as inputs, and it outputs a dense representation of those inputs.

Arguments:

numTokens: The total number of tokens the layer should support. All inputs to the layer must integers in the range 0 <= value < numTokens, or an error will be thrown.

outputMode: Specification for the output of the layer. Defaults to multiHot. Values can be oneHot, multiHot or count, configuring the layer as follows:

oneHot: Encodes each individual element in the input into an
  array of `numTokens` size, containing a 1 at the element index. If
  the last dimension is size 1, will encode on that dimension. If the
  last dimension is not size 1, will append a new dimension for the
  encoded output.

multiHot: Encodes each sample in the input into a single array
 of `numTokens` size, containing a 1 for each vocabulary term
 present in the sample. Treats the last dimension as the sample
 dimension, if input shape is `(..., sampleLength)`, output shape
 will be `(..., numTokens)`.

count: Like `multiHot`, but the int array contains a count of
 the number of times the token at that index appeared in the sample.
For all output modes, currently only output up to rank 2 is supported. Call arguments: inputs: A 1D or 2D tensor of integer inputs. countWeights: A tensor in the same shape as inputs indicating the weight for each sample value when summing up in count mode. Not used in multiHot or oneHot modes.

Parameters:
args (Object)
numTokens (number)
outputMode (OutputMode)
inputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
batchInputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
batchSize (number) If inputShape is specified and batchInputShape is not specified, batchSize is used to construct the batchInputShape: [batchSize, ...inputShape]
dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data-type for this layer. Defaults to 'float32'. This argument is only applicable to input layers (the first layer of a model).
name (string) Name for this layer.
trainable (boolean) Whether the weights of this layer are updatable by fit. Defaults to true.
weights (tf.Tensor[]) Initial weight values of the layer.
inputDType ('float32'|'int32'|'bool'|'complex64'|'string') Legacy support. Do not use for new code.
Returns: CategoryEncoding
Layers / RandomWidth
tf.layers.randomWidth (args) functionSource
A preprocessing layer which randomly varies image width during training.

This layer will randomly adjusts the width of a batch of images of a batch of images by a random factor.

The input should be a 3D (unbatched) or 4D (batched) tensor in the "channels_last" image data format. Input pixel values can be of any range (e.g. [0., 1.) or [0, 255]) and of integer or floating point dtype. By default, the layer will output floats. By default, this layer is inactive during inference. For an overview and full list of preprocessing layers, see the preprocessing [guide] (https://www.tensorflow.org/guide/keras/preprocessing_layers).

Arguments:

factor: A positive float (fraction of original width), or a tuple of size 2 representing lower and upper bound for resizing vertically. When represented as a single float, this value is used for both the upper and lower bound. For instance, factor=(0.2, 0.3) results in an output with width changed by a random amount in the range [20%, 30%]. factor=(-0.2, 0.3) results in an output with width changed by a random amount in the range [-20%, +30%]. factor=0.2 results in an output with width changed by a random amount in the range [-20%, +20%]. interpolation: String, the interpolation method. Defaults to bilinear. Supports "bilinear", "nearest". The tf methods "bicubic", "area", "lanczos3", "lanczos5", "gaussian", "mitchellcubic" are unimplemented in tfjs. seed: Integer. Used to create a random seed.

Input shape: 3D (unbatched) or 4D (batched) tensor with shape: (..., height, width, channels), in "channels_last" format. Output shape: 3D (unbatched) or 4D (batched) tensor with shape: (..., height, random_width, channels).

Parameters:
args (Object)
factor (number | [number, number])
interpolation (InterpolationType)
seed (number)
autoVectorize (boolean)
inputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
batchInputShape ((null | number)[]) If defined, will be used to create an input layer to insert before this layer. If both inputShape and batchInputShape are defined, batchInputShape will be used. This argument is only applicable to input layers (the first layer of a model).
batchSize (number) If inputShape is specified and batchInputShape is not specified, batchSize is used to construct the batchInputShape: [batchSize, ...inputShape]
dtype ('float32'|'int32'|'bool'|'complex64'|'string') The data-type for this layer. Defaults to 'float32'. This argument is only applicable to input layers (the first layer of a model).
name (string) Name for this layer.
trainable (boolean) Whether the weights of this layer are updatable by fit. Defaults to true.
weights (tf.Tensor[]) Initial weight values of the layer.
inputDType ('float32'|'int32'|'bool'|'complex64'|'string') Legacy support. Do not use for new code.
Returns: RandomWidth
Operations
Operations / Arithmetic
To perform mathematical computation on Tensors, we use operations. Tensors are immutable, so all operations always return new Tensors and never modify input Tensors.

tf.add (a, b) functionSource
Adds two tf.Tensors element-wise, A + B. Supports broadcasting.

const a = tf.tensor1d([1, 2, 3, 4]);
const b = tf.tensor1d([10, 20, 30, 40]);

a.add(b).print();  // or tf.add(a, b)
EditRun
// Broadcast add a with b.
const a = tf.scalar(5);
const b = tf.tensor1d([10, 20, 30, 40]);

a.add(b).print();  // or tf.add(a, b)
EditRun
Parameters:
a (tf.Tensor|TypedArray|Array) The first tf.Tensor to add.
b (tf.Tensor|TypedArray|Array) The second tf.Tensor to add. Must have the same type as a.
Returns: tf.Tensor
tf.sub (a, b) functionSource
Subtracts two tf.Tensors element-wise, A - B. Supports broadcasting.

const a = tf.tensor1d([10, 20, 30, 40]);
const b = tf.tensor1d([1, 2, 3, 4]);

a.sub(b).print();  // or tf.sub(a, b)
EditRun
// Broadcast subtract a with b.
const a = tf.tensor1d([10, 20, 30, 40]);
const b = tf.scalar(5);

a.sub(b).print();  // or tf.sub(a, b)
EditRun
Parameters:
a (tf.Tensor|TypedArray|Array) The first tf.Tensor to subtract from.
b (tf.Tensor|TypedArray|Array) The second tf.Tensor to be subtracted. Must have the same dtype as a.
Returns: tf.Tensor
tf.mul (a, b) functionSource
Multiplies two tf.Tensors element-wise, A * B. Supports broadcasting.

We also expose tf.mulStrict which has the same signature as this op and asserts that a and b are the same shape (does not broadcast).

const a = tf.tensor1d([1, 2, 3, 4]);
const b = tf.tensor1d([2, 3, 4, 5]);

a.mul(b).print();  // or tf.mul(a, b)
EditRun
// Broadcast mul a with b.
const a = tf.tensor1d([1, 2, 3, 4]);
const b = tf.scalar(5);

a.mul(b).print();  // or tf.mul(a, b)
EditRun
Parameters:
a (tf.Tensor|TypedArray|Array) The first tensor to multiply.
b (tf.Tensor|TypedArray|Array) The second tensor to multiply. Must have the same dtype as a.
Returns: tf.Tensor
tf.div (a, b) functionSource
Divides two tf.Tensors element-wise, A / B. Supports broadcasting.

const a = tf.tensor1d([1, 4, 9, 16]);
const b = tf.tensor1d([1, 2, 3, 4]);

a.div(b).print();  // or tf.div(a, b)
EditRun
// Broadcast div a with b.
const a = tf.tensor1d([2, 4, 6, 8]);
const b = tf.scalar(2);

a.div(b).print();  // or tf.div(a, b)
EditRun
Parameters:
a (tf.Tensor|TypedArray|Array) The first tensor as the numerator.
b (tf.Tensor|TypedArray|Array) The second tensor as the denominator. Must have the same dtype as a.
Returns: tf.Tensor
tf.addN (tensors) functionSource
Adds a list of tf.Tensors element-wise, each with the same shape and dtype.

const a = tf.tensor1d([1, 2]);
const b = tf.tensor1d([3, 4]);
const c = tf.tensor1d([5, 6]);

tf.addN([a, b, c]).print();
EditRun
Parameters:
tensors (Array) A list of tensors with the same shape and dtype.
Returns: tf.Tensor
tf.divNoNan (a, b) functionSource
Divides two tf.Tensors element-wise, A / B. Supports broadcasting. Return 0 if denominator is 0.

const a = tf.tensor1d([1, 4, 9, 16]);
const b = tf.tensor1d([1, 2, 3, 4]);
const c = tf.tensor1d([0, 0, 0, 0]);

a.divNoNan(b).print();  // or tf.divNoNan(a, b)
a.divNoNan(c).print();  // or tf.divNoNan(a, c)
EditRun
// Broadcast div a with b.
const a = tf.tensor1d([2, 4, 6, 8]);
const b = tf.scalar(2);
const c = tf.scalar(0);

a.divNoNan(b).print();  // or tf.divNoNan(a, b)
a.divNoNan(c).print();  // or tf.divNoNan(a, c)
EditRun
Parameters:
a (tf.Tensor|TypedArray|Array) The first tensor as the numerator.
b (tf.Tensor|TypedArray|Array) The second tensor as the denominator. Must have the same dtype as a.
Returns: tf.Tensor
tf.floorDiv (a, b) functionSource
Divides two tf.Tensors element-wise, A / B. Supports broadcasting. The result is rounded with floor function.

const a = tf.tensor1d([1, 4, 9, 16]);
const b = tf.tensor1d([1, 2, 3, 4]);

a.floorDiv(b).print();  // or tf.div(a, b)
EditRun
// Broadcast div a with b.
const a = tf.tensor1d([2, 4, 6, 8]);
const b = tf.scalar(2);

a.floorDiv(b).print();  // or tf.floorDiv(a, b)
EditRun
Parameters:
a (tf.Tensor|TypedArray|Array) The first tensor as the numerator.
b (tf.Tensor|TypedArray|Array) The second tensor as the denominator. Must have the same dtype as a.
Returns: tf.Tensor
tf.maximum (a, b) functionSource
Returns the max of a and b (a > b ? a : b) element-wise. Supports broadcasting.

We also expose tf.maximumStrict which has the same signature as this op and asserts that a and b are the same shape (does not broadcast).

const a = tf.tensor1d([1, 4, 3, 16]);
const b = tf.tensor1d([1, 2, 9, 4]);

a.maximum(b).print();  // or tf.maximum(a, b)
EditRun
// Broadcast maximum a with b.
const a = tf.tensor1d([2, 4, 6, 8]);
const b = tf.scalar(5);

a.maximum(b).print();  // or tf.maximum(a, b)
EditRun
Parameters:
a (tf.Tensor|TypedArray|Array) The first tensor.
b (tf.Tensor|TypedArray|Array) The second tensor. Must have the same type as a.
Returns: tf.Tensor
tf.minimum (a, b) functionSource
Returns the min of a and b (a < b ? a : b) element-wise. Supports broadcasting.

We also expose minimumStrict which has the same signature as this op and asserts that a and b are the same shape (does not broadcast).

const a = tf.tensor1d([1, 4, 3, 16]);
const b = tf.tensor1d([1, 2, 9, 4]);

a.minimum(b).print();  // or tf.minimum(a, b)
EditRun
// Broadcast minimum a with b.
const a = tf.tensor1d([2, 4, 6, 8]);
const b = tf.scalar(5);

a.minimum(b).print();  // or tf.minimum(a, b)
EditRun
Parameters:
a (tf.Tensor|TypedArray|Array) The first tensor.
b (tf.Tensor|TypedArray|Array) The second tensor. Must have the same type as a.
Returns: tf.Tensor
tf.mod (a, b) functionSource
Returns the mod of a and b element-wise. floor(x / y) * y + mod(x, y) = x Supports broadcasting.

We also expose tf.modStrict which has the same signature as this op and asserts that a and b are the same shape (does not broadcast).

const a = tf.tensor1d([1, 4, 3, 16]);
const b = tf.tensor1d([1, 2, 9, 4]);

a.mod(b).print();  // or tf.mod(a, b)
EditRun
// Broadcast a mod b.
const a = tf.tensor1d([2, 4, 6, 8]);
const b = tf.scalar(5);

a.mod(b).print();  // or tf.mod(a, b)
EditRun
Parameters:
a (tf.Tensor|TypedArray|Array) The first tensor.
b (tf.Tensor|TypedArray|Array) The second tensor. Must have the same type as a.
Returns: tf.Tensor
tf.pow (base, exp) functionSource
Computes the power of one tf.Tensor to another. Supports broadcasting.

Given a tf.Tensor x and a tf.Tensor y, this operation computes x^y for corresponding elements in x and y. The result's dtype will be the upcasted type of the base and exp dtypes.

const a = tf.tensor([[2, 3], [4, 5]])
const b = tf.tensor([[1, 2], [3, 0]]).toInt();

a.pow(b).print();  // or tf.pow(a, b)
EditRun
const a = tf.tensor([[1, 2], [3, 4]])
const b = tf.tensor(2).toInt();

a.pow(b).print();  // or tf.pow(a, b)
EditRun
We also expose powStrict which has the same signature as this op and asserts that base and exp are the same shape (does not broadcast).

Parameters:
base (tf.Tensor|TypedArray|Array) The base tf.Tensor to pow element-wise.
exp (tf.Tensor|TypedArray|Array) The exponent tf.Tensor to pow element-wise.
Returns: tf.Tensor
tf.squaredDifference (a, b) functionSource
Returns (a - b) * (a - b) element-wise. Supports broadcasting.

const a = tf.tensor1d([1, 4, 3, 16]);
const b = tf.tensor1d([1, 2, 9, 4]);

a.squaredDifference(b).print();  // or tf.squaredDifference(a, b)
EditRun
// Broadcast squared difference  a with b.
const a = tf.tensor1d([2, 4, 6, 8]);
const b = tf.scalar(5);

a.squaredDifference(b).print();  // or tf.squaredDifference(a, b)
EditRun
Parameters:
a (tf.Tensor|TypedArray|Array) The first tensor.
b (tf.Tensor|TypedArray|Array) The second tensor. Must have the same type as a.
Returns: tf.Tensor
Operations / Basic math
tf.abs (x) functionSource
Computes absolute value element-wise: abs(x)

const x = tf.tensor1d([-1, 2, -3, 4]);

x.abs().print();  // or tf.abs(x)
EditRun
Parameters:
x (tf.Tensor|TypedArray|Array) The input tf.Tensor.
Returns: tf.Tensor
tf.acos (x) functionSource
Computes acos of the input tf.Tensor element-wise: acos(x)

const x = tf.tensor1d([0, 1, -1, .7]);

x.acos().print();  // or tf.acos(x)
EditRun
Parameters:
x (tf.Tensor|TypedArray|Array) The input tensor.
Returns: tf.Tensor
tf.acosh (x) functionSource
Computes the inverse hyperbolic cos of the input tf.Tensor element-wise: acosh(x)

const x = tf.tensor1d([10, 1, 3, 5.7]);

x.acosh().print();  // or tf.acosh(x)
EditRun
Parameters:
x (tf.Tensor|TypedArray|Array) The input tensor.
Returns: tf.Tensor
tf.asin (x) functionSource
Computes asin of the input tf.Tensor element-wise: asin(x)

const x = tf.tensor1d([0, 1, -1, .7]);

x.asin().print();  // or tf.asin(x)
EditRun
Parameters:
x (tf.Tensor|TypedArray|Array) The input tensor.
Returns: tf.Tensor
tf.asinh (x) functionSource
Computes inverse hyperbolic sin of the input tf.Tensor element-wise: asinh(x)

const x = tf.tensor1d([0, 1, -1, .7]);

x.asinh().print();  // or tf.asinh(x)
EditRun
Parameters:
x (tf.Tensor|TypedArray|Array) The input tensor.
Returns: tf.Tensor
tf.atan (x) functionSource
Computes atan of the input tf.Tensor element-wise: atan(x)

const x = tf.tensor1d([0, 1, -1, .7]);

x.atan().print();  // or tf.atan(x)
EditRun
Parameters:
x (tf.Tensor|TypedArray|Array) The input tensor.
Returns: tf.Tensor
tf.atan2 (a, b) functionSource
Computes arctangent of tf.Tensors a / b element-wise: atan2(a, b). Supports broadcasting.

const a = tf.tensor1d([1.0, 1.0, -1.0, .7]);
const b = tf.tensor1d([2.0, 13.0, 3.5, .21]);

tf.atan2(a, b).print()
EditRun
Parameters:
a (tf.Tensor|TypedArray|Array) The first tensor.
b (tf.Tensor|TypedArray|Array) The second tensor. Must have the same dtype as a.
Returns: tf.Tensor
tf.atanh (x) functionSource
Computes inverse hyperbolic tan of the input tf.Tensor element-wise: atanh(x)

const x = tf.tensor1d([0, .1, -.1, .7]);

x.atanh().print();  // or tf.atanh(x)
EditRun
Parameters:
x (tf.Tensor|TypedArray|Array) The input tensor.
Returns: tf.Tensor
tf.ceil (x) functionSource
Computes ceiling of input tf.Tensor element-wise: ceil(x)

const x = tf.tensor1d([.6, 1.1, -3.3]);

x.ceil().print();  // or tf.ceil(x)
EditRun
Parameters:
x (tf.Tensor|TypedArray|Array) The input Tensor.
Returns: tf.Tensor
tf.clipByValue (x, clipValueMin, clipValueMax) functionSource
Clips values element-wise. max(min(x, clipValueMax), clipValueMin)

const x = tf.tensor1d([-1, 2, -3, 4]);

x.clipByValue(-2, 3).print();  // or tf.clipByValue(x, -2, 3)
EditRun
Parameters:
x (tf.Tensor|TypedArray|Array) The input tensor.
clipValueMin (number) Lower bound of range to be clipped to.
clipValueMax (number) Upper bound of range to be clipped to.
Returns: tf.Tensor
tf.cos (x) functionSource
Computes cos of the input tf.Tensor element-wise: cos(x)

const x = tf.tensor1d([0, Math.PI / 2, Math.PI * 3 / 4]);

x.cos().print();  // or tf.cos(x)
EditRun
Parameters:
x (tf.Tensor|TypedArray|Array) The input tensor. Must be float32 type.
Returns: tf.Tensor
tf.cosh (x) functionSource
Computes hyperbolic cos of the input tf.Tensor element-wise: cosh(x)

const x = tf.tensor1d([0, 1, -1, .7]);

x.cosh().print();  // or tf.cosh(x)
EditRun
Parameters:
x (tf.Tensor|TypedArray|Array) The input tensor. Must be float32 type.
Returns: tf.Tensor
tf.elu (x) functionSource
Computes exponential linear element-wise: x > 0 ? x : (e ^ x) - 1.

const x = tf.tensor1d([-1, 1, -3, 2]);

x.elu().print();  // or tf.elu(x)
EditRun
Parameters:
x (tf.Tensor|TypedArray|Array) The input tensor.
Returns: tf.Tensor
tf.erf (x) functionSource
Computes Gauss error function of the input tf.Tensor element-wise: erf(x)

const x = tf.tensor1d([0, .1, -.1, .7]);

x.erf().print(); // or tf.erf(x);
EditRun
Parameters:
x (tf.Tensor|TypedArray|Array) The input tensor.
Returns: tf.Tensor
tf.exp (x) functionSource
Computes exponential of the input tf.Tensor element-wise. e ^ x

const x = tf.tensor1d([1, 2, -3]);

x.exp().print();  // or tf.exp(x)
EditRun
Parameters:
x (tf.Tensor|TypedArray|Array) The input tensor.
Returns: tf.Tensor
tf.expm1 (x) functionSource
Computes exponential of the input tf.Tensor minus one element-wise. e ^ x - 1

const x = tf.tensor1d([1, 2, -3]);

x.expm1().print();  // or tf.expm1(x)
EditRun
Parameters:
x (tf.Tensor|TypedArray|Array) The input tensor.
Returns: tf.Tensor
tf.floor (x) functionSource
Computes floor of input tf.Tensor element-wise: floor(x).

const x = tf.tensor1d([.6, 1.1, -3.3]);

x.floor().print();  // or tf.floor(x)
EditRun
Parameters:
x (tf.Tensor|TypedArray|Array) The input tensor.
Returns: tf.Tensor
tf.isFinite (x) functionSource
Returns which elements of x are finite.

const x = tf.tensor1d([NaN, Infinity, -Infinity, 0, 1]);

x.isFinite().print();  // or tf.isNaN(x)
EditRun
Parameters:
x (tf.Tensor|TypedArray|Array) The input Tensor.
Returns: tf.Tensor
tf.isInf (x) functionSource
Returns which elements of x are Infinity or -Infinity.

const x = tf.tensor1d([NaN, Infinity, -Infinity, 0, 1]);

x.isInf().print();  // or tf.isNaN(x)
EditRun
Parameters:
x (tf.Tensor|TypedArray|Array) The input Tensor.
Returns: tf.Tensor
tf.isNaN (x) functionSource
Returns which elements of x are NaN.

const x = tf.tensor1d([NaN, Infinity, -Infinity, 0, 1]);

x.isNaN().print();  // or tf.isNaN(x)
EditRun
Parameters:
x (tf.Tensor|TypedArray|Array) The input Tensor.
Returns: tf.Tensor
tf.leakyRelu (x, alpha?) functionSource
Computes leaky rectified linear element-wise.

See http://web.stanford.edu/~awni/papers/relu_hybrid_icml2013_final.pdf

const x = tf.tensor1d([-1, 2, -3, 4]);

x.leakyRelu(0.1).print();  // or tf.leakyRelu(x, 0.1)
EditRun
Parameters:
x (tf.Tensor|TypedArray|Array) The input tensor.
alpha (number) The scaling factor for negative values, defaults to 0.2. Optional
Returns: tf.Tensor
tf.log (x) functionSource
Computes natural logarithm of the input tf.Tensor element-wise: ln(x)

const x = tf.tensor1d([1, 2, Math.E]);

x.log().print();  // or tf.log(x)
EditRun
Parameters:
x (tf.Tensor|TypedArray|Array) The input tensor.
Returns: tf.Tensor
tf.log1p (x) functionSource
Computes natural logarithm of the input tf.Tensor plus one element-wise: ln(1 + x)

const x = tf.tensor1d([1, 2, Math.E - 1]);

x.log1p().print();  // or tf.log1p(x)
EditRun
Parameters:
x (tf.Tensor|TypedArray|Array) The input tensor.
Returns: tf.Tensor
tf.logSigmoid (x) functionSource
Computes log sigmoid of the input tf.Tensor element-wise: logSigmoid(x). For numerical stability, we use -tf.softplus(-x).

const x = tf.tensor1d([0, 1, -1, .7]);

x.logSigmoid().print();  // or tf.logSigmoid(x)
EditRun
Parameters:
x (tf.Tensor|TypedArray|Array) The input tensor.
Returns: tf.Tensor
tf.neg (x) functionSource
Computes -1 * x element-wise.

const x = tf.tensor2d([1, 2, -2, 0], [2, 2]);

x.neg().print();  // or tf.neg(x)
EditRun
Parameters:
x (tf.Tensor|TypedArray|Array) The input tensor.
Returns: tf.Tensor
tf.prelu (x, alpha) functionSource
Computes leaky rectified linear element-wise with parametric alphas.

x < 0 ? alpha * x : f(x) = x

const x = tf.tensor1d([-1, 2, -3, 4]);
const alpha = tf.scalar(0.1);

x.prelu(alpha).print();  // or tf.prelu(x, alpha)
EditRun
Parameters:
x (tf.Tensor|TypedArray|Array) The input tensor.
alpha (tf.Tensor|TypedArray|Array) Scaling factor for negative values.
Returns: tf.Tensor
tf.reciprocal (x) functionSource
Computes reciprocal of x element-wise: 1 / x

const x = tf.tensor1d([0, 1, 2]);

x.reciprocal().print();  // or tf.reciprocal(x)
EditRun
Parameters:
x (tf.Tensor|TypedArray|Array) The input tensor.
Returns: tf.Tensor
tf.relu (x) functionSource
Computes rectified linear element-wise: max(x, 0).

const x = tf.tensor1d([-1, 2, -3, 4]);

x.relu().print();  // or tf.relu(x)
EditRun
Parameters:
x (tf.Tensor|TypedArray|Array) The input tensor. If the dtype is bool, the output dtype will be int32.
Returns: tf.Tensor
tf.relu6 (x) functionSource
Computes rectified linear 6 element-wise: min(max(x, 0), 6).

const x = tf.tensor1d([-1, 2, -3, 8]);

x.relu6().print();  // or tf.relu6(x)
EditRun
Parameters:
x (tf.Tensor|TypedArray|Array) The input tensor. If the dtype is bool, the output dtype will be int32.
Returns: tf.Tensor
tf.round (x) functionSource
Computes round of input tf.Tensor element-wise: round(x). It implements banker's rounding.

const x = tf.tensor1d([.6, 1.1, -3.3]);

x.round().print();  // or tf.round(x)
EditRun
Parameters:
x (tf.Tensor|TypedArray|Array) The input tensor.
Returns: tf.Tensor
tf.rsqrt (x) functionSource
Computes reciprocal of square root of the input tf.Tensor element-wise: y = 1 / sqrt(x)

const x = tf.tensor1d([1, 2, 4, -1]);

x.rsqrt().print();  // or tf.rsqrt(x)
EditRun
Parameters:
x (tf.Tensor|TypedArray|Array) The input tensor.
Returns: tf.Tensor
tf.selu (x) functionSource
Computes scaled exponential linear element-wise.

x < 0 ? scale * alpha * (exp(x) - 1) : scale * x

const x = tf.tensor1d([-1, 2, -3, 4]);

x.selu().print();  // or tf.selu(x)
EditRun
Parameters:
x (tf.Tensor|TypedArray|Array) The input tensor.
Returns: tf.Tensor
tf.sigmoid (x) functionSource
Computes sigmoid element-wise, 1 / (1 + exp(-x))

const x = tf.tensor1d([0, -1, 2, -3]);

x.sigmoid().print();  // or tf.sigmoid(x)
EditRun
Parameters:
x (tf.Tensor|TypedArray|Array) The input tensor.
Returns: tf.Tensor
tf.sign (x) functionSource
Returns an element-wise indication of the sign of a number.

const x = tf.tensor1d([.6, 1.1, -3.3, NaN, 0]);

x.sign().print();  // or tf.sign(x)
EditRun
Parameters:
x (tf.Tensor|TypedArray|Array) The input Tensor.
Returns: tf.Tensor
tf.sin (x) functionSource
Computes sin of the input Tensor element-wise: sin(x)

const x = tf.tensor1d([0, Math.PI / 2, Math.PI * 3 / 4]);

x.sin().print();  // or tf.sin(x)
EditRun
Parameters:
x (tf.Tensor|TypedArray|Array) The input tensor.
Returns: tf.Tensor
tf.sinh (x) functionSource
Computes hyperbolic sin of the input tf.Tensor element-wise: sinh(x)

const x = tf.tensor1d([0, 1, -1, .7]);

x.sinh().print();  // or tf.sinh(x)
EditRun
Parameters:
x (tf.Tensor|TypedArray|Array) The input tensor.
Returns: tf.Tensor
tf.softplus (x) functionSource
Computes softplus of the input tf.Tensor element-wise: log(exp(x) + 1)

const x = tf.tensor1d([0, 1, -1, .7]);

x.softplus().print();  // or tf.softplus(x)
EditRun
Parameters:
x (tf.Tensor|TypedArray|Array) The input tensor.
Returns: tf.Tensor
tf.sqrt (x) functionSource
Computes square root of the input tf.Tensor element-wise: y = sqrt(x)

const x = tf.tensor1d([1, 2, 4, -1]);

x.sqrt().print();  // or tf.sqrt(x)
EditRun
Parameters:
x (tf.Tensor|TypedArray|Array) The input tensor.
Returns: tf.Tensor
tf.square (x) functionSource
Computes square of x element-wise: x ^ 2

const x = tf.tensor1d([1, 2, Math.sqrt(2), -1]);

x.square().print();  // or tf.square(x)
EditRun
Parameters:
x (tf.Tensor|TypedArray|Array) The input Tensor.
Returns: tf.Tensor
tf.step (x, alpha?) functionSource
Computes step of the input tf.Tensor element-wise: x > 0 ? 1 : alpha

const x = tf.tensor1d([0, 2, -1, -3]);

x.step(.5).print();  // or tf.step(x, .5)
EditRun
Parameters:
x (tf.Tensor|TypedArray|Array) The input tensor.
alpha (number) The gradient when input is negative. Defaults to 0. Optional
Returns: tf.Tensor
tf.tan (x) functionSource
Computes tan of the input tf.Tensor element-wise, tan(x)

const x = tf.tensor1d([0, Math.PI / 2, Math.PI * 3 / 4]);

x.tan().print();  // or tf.tan(x)
EditRun
Parameters:
x (tf.Tensor|TypedArray|Array) The input tensor.
Returns: tf.Tensor
tf.tanh (x) functionSource
Computes hyperbolic tangent of the input tf.Tensor element-wise: tanh(x)

const x = tf.tensor1d([0, 1, -1, 70]);

x.tanh().print();  // or tf.tanh(x)
EditRun
Parameters:
x (tf.Tensor|TypedArray|Array) The input tensor.
Returns: tf.Tensor
Operations / Matrices
tf.dot (t1, t2) functionSource
Computes the dot product of two matrices and/or vectors, t1 and t2.

const a = tf.tensor1d([1, 2]);
const b = tf.tensor2d([[1, 2], [3, 4]]);
const c = tf.tensor2d([[1, 2, 3], [4, 5, 6]]);

a.dot(b).print();  // or tf.dot(a, b)
b.dot(a).print();
b.dot(c).print();
EditRun
Parameters:
t1 (tf.Tensor|TypedArray|Array) The first tensor in the dot operation.
t2 (tf.Tensor|TypedArray|Array) The second tensor in the dot operation.
Returns: tf.Tensor
tf.euclideanNorm (x, axis?, keepDims?) functionSource
Computes the Euclidean norm of scalar, vectors, and matrices.

const x = tf.tensor1d([1, 2, 3, 4]);

x.euclideanNorm().print();  // or tf.euclideanNorm(x)
EditRun
Parameters:
x (tf.Tensor|TypedArray|Array) The input array.
axis (number|number[]) Optional. If axis is null (the default), the input is considered a vector and a single vector norm is computed over the entire set of values in the Tensor, i.e. euclideanNorm(x) is equivalent to euclideanNorm(x.reshape([-1])). If axis is an integer, the input is considered a batch of vectors, and axis determines the axis in x over which to compute vector norms. If axis is a 2-tuple of integer it is considered a batch of matrices and axis determines the axes in NDArray over which to compute a matrix norm. Optional
keepDims (boolean) Optional. If true, the norm has the same dimensionality as the input. Optional
Returns: tf.Tensor
tf.matMul (a, b, transposeA?, transposeB?) functionSource
Computes the dot product of two matrices, A * B. These must be matrices.

const a = tf.tensor2d([1, 2], [1, 2]);
const b = tf.tensor2d([1, 2, 3, 4], [2, 2]);

a.matMul(b).print();  // or tf.matMul(a, b)
EditRun
Parameters:
a (tf.Tensor|TypedArray|Array) First matrix in dot product operation.
b (tf.Tensor|TypedArray|Array) Second matrix in dot product operation.
transposeA (boolean) If true, a is transposed before multiplication. Optional
transposeB (boolean) If true, b is transposed before multiplication. Optional
Returns: tf.Tensor
tf.norm (x, ord?, axis?, keepDims?) functionSource
Computes the norm of scalar, vectors, and matrices. This function can compute several different vector norms (the 1-norm, the Euclidean or 2-norm, the inf-norm, and in general the p-norm for p > 0) and matrix norms (Frobenius, 1-norm, and inf-norm).

const x = tf.tensor1d([1, 2, 3, 4]);

x.norm().print();  // or tf.norm(x)
EditRun
Parameters:
x (tf.Tensor|TypedArray|Array) The input array.
ord (number|'euclidean'|'fro') Optional. Order of the norm. Supported norm types are following:
ord	norm for matrices	norm for vectors
'euclidean'	Frobenius norm	2-norm
'fro'	Frobenius norm	
Infinity	max(sum(abs(x), axis=1))	max(abs(x))
-Infinity	min(sum(abs(x), axis=1))	min(abs(x))
1	max(sum(abs(x), axis=0))	sum(abs(x))
2		sum(abs(x)^2)^(1/2)
Optional
axis (number|number[]) Optional. If axis is null (the default), the input is considered a vector and a single vector norm is computed over the entire set of values in the Tensor, i.e. norm(x, ord) is equivalent to norm(x.reshape([-1]), ord). If axis is an integer, the input is considered a batch of vectors, and axis determines the axis in x over which to compute vector norms. If axis is a 2-tuple of integer it is considered a batch of matrices and axis determines the axes in NDArray over which to compute a matrix norm. Optional
keepDims (boolean) Optional. If true, the norm has the same dimensionality as the input. Optional
Returns: tf.Tensor
tf.outerProduct (v1, v2) functionSource
Computes the outer product of two vectors, v1 and v2.

const a = tf.tensor1d([1, 2, 3]);
const b = tf.tensor1d([3, 4, 5]);

tf.outerProduct(a, b).print();
EditRun
Parameters:
v1 (tf.Tensor1D|TypedArray|Array) The first vector in the outer product operation.
v2 (tf.Tensor1D|TypedArray|Array) The second vector in the outer product operation.
Returns: tf.Tensor2D
tf.transpose (x, perm?, conjugate?) functionSource
Transposes the tf.Tensor. Permutes the dimensions according to perm.

The returned tf.Tensor's dimension i will correspond to the input dimension perm[i]. If perm is not given, it is set to [n-1...0], where n is the rank of the input tf.Tensor. Hence by default, this operation performs a regular matrix transpose on 2-D input tf.Tensors.

const a = tf.tensor2d([1, 2, 3, 4, 5, 6], [2, 3]);

a.transpose().print();  // or tf.transpose(a)
EditRun
Parameters:
x (tf.Tensor|TypedArray|Array) The tensor to transpose.
perm (number[]) The permutation of the dimensions of a. Optional
conjugate (boolean) Will conjugate complex input if true. Optional
Returns: tf.Tensor
Operations / Convolution
tf.avgPool (x, filterSize, strides, pad, dimRoundingMode?) functionSource
Computes the 2D average pooling of an image.

Parameters:
x (tf.Tensor3D|tf.Tensor4D|TypedArray|Array) The input tensor, of rank 4 or rank 3 of shape [batch, height, width, inChannels]. If rank 3, batch of 1 is assumed.
filterSize ([number, number]|number) The filter size: [filterHeight, filterWidth]. If filterSize is a single number, then filterHeight == filterWidth.
strides ([number, number]|number) The strides of the pooling: [strideHeight, strideWidth]. If strides is a single number, then strideHeight == strideWidth.
pad ('valid'|'same'|number|conv_util.ExplicitPadding) The type of padding algorithm:
same and stride 1: output will be of same size as input, regardless of filter size.
valid: output will be smaller than input if filter is larger than 1x1.
For more info, see this guide: https://www.tensorflow.org/api_docs/python/tf/nn/convolution
dimRoundingMode ('floor'|'round'|'ceil') A string from: 'ceil', 'round', 'floor'. If none is provided, it will default to truncate. Optional
Returns: tf.Tensor3D|tf.Tensor4D
tf.avgPool3d (x, filterSize, strides, pad, dimRoundingMode?, dataFormat?) functionSource
Computes the 3D average pooling.

const x = tf.tensor5d([1, 2, 3, 4, 5, 6, 7, 8], [1, 2, 2, 2, 1]);
const result = tf.avgPool3d(x, 2, 1, 'valid');
result.print();
EditRun
Parameters:
x (tf.Tensor4D|tf.Tensor5D|TypedArray|Array) The input tensor, of rank 5 or rank 4 of shape [batch, depth, height, width, inChannels].
filterSize ([number, number, number]|number) The filter size: [filterDepth, filterHeight, filterWidth]. If filterSize is a single number, then filterDepth == filterHeight == filterWidth.
strides ([number, number, number]|number) The strides of the pooling: [strideDepth, strideHeight, strideWidth]. If strides is a single number, then strideDepth == strideHeight == strideWidth.
pad ('valid'|'same'|number) The type of padding algorithm.
same and stride 1: output will be of same size as input, regardless of filter size.
valid: output will be smaller than input if filter is larger than 1*1x1.
For more info, see this guide: https://www.tensorflow.org/api_docs/python/tf/nn/convolution
dimRoundingMode ('floor'|'round'|'ceil') A string from: 'ceil', 'round', 'floor'. If none is provided, it will default to truncate. Optional
dataFormat ('NDHWC'|'NCDHW') An optional string from: "NDHWC", "NCDHW". Defaults to "NDHWC". Specify the data format of the input and output data. With the default format "NDHWC", the data is stored in the order of: [batch, depth, height, width, channels]. Only "NDHWC" is currently supported. Optional
Returns: tf.Tensor4D|tf.Tensor5D
tf.conv1d (x, filter, stride, pad, dataFormat?, dilation?, dimRoundingMode?) functionSource
Computes a 1D convolution over the input x.

Parameters:
x (tf.Tensor2D|tf.Tensor3D|TypedArray|Array) The input tensor, of rank 3 or rank 2, of shape [batch, width, inChannels]. If rank 2, batch of 1 is assumed.
filter (tf.Tensor3D|TypedArray|Array) The filter, rank 3, of shape [filterWidth, inDepth, outDepth].
stride (number) The number of entries by which the filter is moved right at each step.
pad ('valid'|'same'|number|conv_util.ExplicitPadding) The type of padding algorithm.
same and stride 1: output will be of same size as input, regardless of filter size.
valid: output will be smaller than input if filter is larger than 1x1.
For more info, see this guide: https://www.tensorflow.org/api_docs/python/tf/nn/convolution
dataFormat ('NWC'|'NCW') An optional string from "NWC", "NCW". Defaults to "NWC", the data is stored in the order of [batch, in_width, in_channels]. Only "NWC" is currently supported. Optional
dilation (number) The dilation rate in which we sample input values in atrous convolution. Defaults to 1. If it is greater than 1, then stride must be 1. Optional
dimRoundingMode ('floor'|'round'|'ceil') A string from: 'ceil', 'round', 'floor'. If none is provided, it will default to truncate. Optional
Returns: tf.Tensor2D|tf.Tensor3D
tf.conv2d (x, filter, strides, pad, dataFormat?, dilations?, dimRoundingMode?) functionSource
Computes a 2D convolution over the input x.

Parameters:
x (tf.Tensor3D|tf.Tensor4D|TypedArray|Array) The input tensor, of rank 4 or rank 3, of shape [batch, height, width, inChannels]. If rank 3, batch of 1 is assumed.
filter (tf.Tensor4D|TypedArray|Array) The filter, rank 4, of shape [filterHeight, filterWidth, inDepth, outDepth].
strides ([number, number]|number) The strides of the convolution: [strideHeight, strideWidth].
pad ('valid'|'same'|number|conv_util.ExplicitPadding) The type of padding algorithm.
same and stride 1: output will be of same size as input, regardless of filter size.
valid: output will be smaller than input if filter is larger than 1x1.
For more info, see this guide: https://www.tensorflow.org/api_docs/python/tf/nn/convolution
dataFormat ('NHWC'|'NCHW') : An optional string from: "NHWC", "NCHW". Defaults to "NHWC". Specify the data format of the input and output data. With the default format "NHWC", the data is stored in the order of: [batch, height, width, channels]. Optional
dilations ([number, number]|number) The dilation rates: [dilationHeight, dilationWidth] in which we sample input values across the height and width dimensions in atrous convolution. Defaults to [1, 1]. If dilations is a single number, then dilationHeight == dilationWidth. If it is greater than 1, then all values of strides must be 1. Optional
dimRoundingMode ('floor'|'round'|'ceil') A string from: 'ceil', 'round', 'floor'. If none is provided, it will default to truncate. Optional
Returns: tf.Tensor3D|tf.Tensor4D
tf.conv2dTranspose (x, filter, outputShape, strides, pad, dimRoundingMode?) functionSource
Computes the transposed 2D convolution of an image, also known as a deconvolution.

Parameters:
x (tf.Tensor3D|tf.Tensor4D|TypedArray|Array) The input image, of rank 4 or rank 3, of shape [batch, height, width, inDepth]. If rank 3, batch of 1 is assumed.
filter (tf.Tensor4D|TypedArray|Array) The filter, rank 4, of shape [filterHeight, filterWidth, outDepth, inDepth]. inDepth must match inDepth in x.
outputShape ([number, number, number, number]|[number, number, number]) Output shape, of rank 4 or rank 3: [batch, height, width, outDepth]. If rank 3, batch of 1 is assumed.
strides ([number, number]|number) The strides of the original convolution: [strideHeight, strideWidth].
pad ('valid'|'same'|number|ExplicitPadding) The type of padding algorithm used in the non-transpose version of the op.
dimRoundingMode ('floor'|'round'|'ceil') A string from: 'ceil', 'round', 'floor'. If none is provided, it will default to truncate. Optional
Returns: tf.Tensor3D|tf.Tensor4D
tf.conv3d (x, filter, strides, pad, dataFormat?, dilations?) functionSource
Computes a 3D convolution over the input x.

Parameters:
x (tf.Tensor4D|tf.Tensor5D|TypedArray|Array) The input tensor, of rank 5 or rank 4, of shape [batch, depth, height, width, channels]. If rank 4, batch of 1 is assumed.
filter (tf.Tensor5D|TypedArray|Array) The filter, rank 5, of shape [filterDepth, filterHeight, filterWidth, inChannels, outChannels]. inChannels must match between input and filter.
strides ([number, number, number]|number) The strides of the convolution: [strideDepth, strideHeight, strideWidth].
pad ('valid'|'same') The type of padding algorithm.
same and stride 1: output will be of same size as input, regardless of filter size.
valid: output will be smaller than input if filter is larger than 1x1.
For more info, see this guide: https://www.tensorflow.org/api_docs/python/tf/nn/convolution
dataFormat ('NDHWC'|'NCDHW') : An optional string from: "NDHWC", "NCDHW". Defaults to "NDHWC". Specify the data format of the input and output data. With the default format "NDHWC", the data is stored in the order of: [batch, depth, height, width, channels]. Only "NDHWC" is currently supported. Optional
dilations ([number, number, number]|number) The dilation rates: [dilationDepth, dilationHeight, dilationWidth] in which we sample input values across the height and width dimensions in atrous convolution. Defaults to [1, 1, 1]. If dilations is a single number, then dilationDepth == dilationHeight == dilationWidth. If it is greater than 1, then all values of strides must be 1. Optional
Returns: tf.Tensor4D|tf.Tensor5D
tf.conv3dTranspose (x, filter, outputShape, strides, pad) functionSource
Computes the transposed 3D convolution of a volume, also known as a deconvolution.

Parameters:
x (tf.Tensor4D|tf.Tensor5D|TypedArray|Array) The input image, of rank 5 or rank 4, of shape [batch, depth, height, width, inDepth]. If rank 4, batch of 1 is assumed.
filter (tf.Tensor5D|TypedArray|Array) The filter, rank 4, of shape [depth, filterHeight, filterWidth, outDepth, inDepth]. inDepth must match inDepth in x.
outputShape ([number, number, number, number, number]|[number, number, number, number]) Output shape, of rank 5 or rank 4: [batch, depth, height, width, outDepth]. If rank 3, batch of 1 is assumed.
strides ([number, number, number]|number) The strides of the original convolution: [strideDepth, strideHeight, strideWidth].
pad ('valid'|'same') The type of padding algorithm used in the non-transpose version of the op.
Returns: tf.Tensor4D|tf.Tensor5D
tf.depthwiseConv2d (x, filter, strides, pad, dataFormat?, dilations?, dimRoundingMode?) functionSource
Depthwise 2D convolution.

Given a 4D input array and a filter array of shape [filterHeight, filterWidth, inChannels, channelMultiplier] containing inChannels convolutional filters of depth 1, this op applies a different filter to each input channel (expanding from 1 channel to channelMultiplier channels for each), then concatenates the results together. The output has inChannels * channelMultiplier channels.

See https://www.tensorflow.org/api_docs/python/tf/nn/depthwise_conv2d for more details.

Parameters:
x (tf.Tensor3D|tf.Tensor4D|TypedArray|Array) The input tensor, of rank 4 or rank 3, of shape [batch, height, width, inChannels]. If rank 3, batch of 1 is assumed.
filter (tf.Tensor4D|TypedArray|Array) The filter tensor, rank 4, of shape [filterHeight, filterWidth, inChannels, channelMultiplier].
strides ([number, number]|number) The strides of the convolution: [strideHeight, strideWidth]. If strides is a single number, then strideHeight == strideWidth.
pad ('valid'|'same'|number|conv_util.ExplicitPadding) The type of padding algorithm.
same and stride 1: output will be of same size as input, regardless of filter size.
valid: output will be smaller than input if filter is larger than 1x1.
For more info, see this guide: https://www.tensorflow.org/api_docs/python/tf/nn/convolution
dataFormat ('NHWC'|'NCHW') : An optional string from: "NHWC", "NCHW". Defaults to "NHWC". Specify the data format of the input and output data. With the default format "NHWC", the data is stored in the order of: [batch, height, width, channels]. Only "NHWC" is currently supported. Optional
dilations ([number, number]|number) The dilation rates: [dilationHeight, dilationWidth] in which we sample input values across the height and width dimensions in atrous convolution. Defaults to [1, 1]. If rate is a single number, then dilationHeight == dilationWidth. If it is greater than 1, then all values of strides must be 1. Optional
dimRoundingMode ('floor'|'round'|'ceil') A string from: 'ceil', 'round', 'floor'. If none is provided, it will default to truncate. Optional
Returns: tf.Tensor3D|tf.Tensor4D
tf.dilation2d (x, filter, strides, pad, dilations?, dataFormat?) functionSource
Computes the grayscale dilation over the input x.

Parameters:
x (tf.Tensor3D|tf.Tensor4D|TypedArray|Array) The input tensor, rank 3 or rank 4 of shape [batch, height, width, depth]. If rank 3, batch of 1 is assumed.
filter (tf.Tensor3D|TypedArray|Array) The filter tensor, rank 3, of shape [filterHeight, filterWidth, depth].
strides ([number, number]|number) The strides of the sliding window for each dimension of the input tensor: [strideHeight, strideWidth]. If strides is a single number, then strideHeight == strideWidth.
pad ('valid'|'same') The type of padding algorithm.
same and stride 1: output will be of same size as input, regardless of filter size.
valid: output will be smaller than input if filter is larger than 1*1x1.
For more info, see this guide: https://www.tensorflow.org/api_docs/python/tf/nn/convolution
dilations ([number, number]|number) The dilation rates: [dilationHeight, dilationWidth] in which we sample input values across the height and width dimensions for atrous morphological dilation. Defaults to [1, 1]. If dilations is a single number, then dilationHeight == dilationWidth. If it is greater than 1, then all values of strides must be 1. Optional
dataFormat ('NHWC') Specify the data format of the input and output data. Defaults to 'NHWC'. Only 'NHWC' is currently supported. With the default format "NHWC", the data is stored in the order of: [batch, height, width, channels]. Optional
Returns: tf.Tensor3D|tf.Tensor4D
tf.maxPool3d (x, filterSize, strides, pad, dimRoundingMode?, dataFormat?) functionSource
Computes the 3D max pooling.

const x = tf.tensor5d([1, 2, 3, 4, 5, 6, 7, 8], [1, 2, 2, 2, 1]);
const result = tf.maxPool3d(x, 2, 1, 'valid');
result.print();
EditRun
Parameters:
x (tf.Tensor4D|tf.Tensor5D|TypedArray|Array) The input tensor, of rank 5 or rank 4 of shape [batch, depth, height, width, inChannels].
filterSize ([number, number, number]|number) The filter size: [filterDepth, filterHeight, filterWidth]. If filterSize is a single number, then filterDepth == filterHeight == filterWidth.
strides ([number, number, number]|number) The strides of the pooling: [strideDepth, strideHeight, strideWidth]. If strides is a single number, then strideDepth == strideHeight == strideWidth.
pad ('valid'|'same'|number) The type of padding algorithm.
same and stride 1: output will be of same size as input, regardless of filter size.
valid: output will be smaller than input if filter is larger than 1*1x1.
For more info, see this guide: https://www.tensorflow.org/api_docs/python/tf/nn/convolution
dimRoundingMode ('floor'|'round'|'ceil') A string from: 'ceil', 'round', 'floor'. If none is provided, it will default to truncate. Optional
dataFormat ('NDHWC'|'NCDHW') An optional string from: "NDHWC", "NCDHW". Defaults to "NDHWC". Specify the data format of the input and output data. With the default format "NDHWC", the data is stored in the order of: [batch, depth, height, width, channels]. Only "NDHWC" is currently supported. Optional
Returns: tf.Tensor4D|tf.Tensor5D
tf.maxPoolWithArgmax (x, filterSize, strides, pad, includeBatchInIndex?) functionSource
Computes the 2D max pooling of an image with Argmax index. The indices in argmax are flattened, so that a maximum value at position [b, y, x, c] becomes flattened index: (y * width + x) * channels + c if include_batch_in_index is False; ((b * height + y) * width + x) * channels +c if include_batch_in_index is True.

The indices returned are always in [0, height) x [0, width) before flattening.

Parameters:
x (tf.Tensor4D|TypedArray|Array) The input tensor, of rank 4 or rank 3 of shape [batch, height, width, inChannels]. If rank 3, batch of 1 is assumed.
filterSize ([number, number]|number) The filter size: [filterHeight, filterWidth]. If filterSize is a single number, then filterHeight == filterWidth.
strides ([number, number]|number) The strides of the pooling: [strideHeight, strideWidth]. If strides is a single number, then strideHeight == strideWidth.
pad ('valid'|'same'|number) The type of padding algorithm.
same and stride 1: output will be of same size as input, regardless of filter size.
valid: output will be smaller than input if filter is larger than 1x1.
For more info, see this guide: https://www.tensorflow.org/api_docs/python/tf/nn/convolution
includeBatchInIndex (boolean) Optional
Returns: {[name: string]: tf.Tensor}
tf.pool (input, windowShape, poolingType, pad, dilations?, strides?, dimRoundingMode?) functionSource
Performs an N-D pooling operation

Parameters:
input (tf.Tensor3D|tf.Tensor4D|TypedArray|Array) The input tensor, of rank 4 or rank 3 of shape [batch, height, width, inChannels]. If rank 3, batch of 1 is assumed.
windowShape ([number, number]|number) The filter size: [filterHeight, filterWidth]. If filterSize is a single number, then filterHeight == filterWidth.
poolingType ('avg'|'max') The type of pooling, either 'max' or 'avg'.
pad ('valid'|'same'|number|conv_util.ExplicitPadding) The type of padding algorithm:
same and stride 1: output will be of same size as input, regardless of filter size.
valid: output will be smaller than input if filter is larger than 1x1.
For more info, see this guide: https://www.tensorflow.org/api_guides/python/nn#Convolution
dilations ([number, number]|number) The dilation rates: [dilationHeight, dilationWidth] in which we sample input values across the height and width dimensions in dilated pooling. Defaults to [1, 1]. If dilationRate is a single number, then dilationHeight == dilationWidth. If it is greater than 1, then all values of strides must be 1. Optional
strides ([number, number]|number) The strides of the pooling: [strideHeight, strideWidth]. If strides is a single number, then strideHeight == strideWidth. Optional
dimRoundingMode ('floor'|'round'|'ceil') A string from: 'ceil', 'round', 'floor'. If none is provided, it will default to truncate. Optional
Returns: tf.Tensor3D|tf.Tensor4D
tf.separableConv2d (x, depthwiseFilter, pointwiseFilter, strides, pad, dilation?, dataFormat?) functionSource
2-D convolution with separable filters.

Performs a depthwise convolution that acts separately on channels followed by a pointwise convolution that mixes channels. Note that this is separability between dimensions [1, 2] and 3, not spatial separability between dimensions 1 and 2.

See https://www.tensorflow.org/api_docs/python/tf/nn/separable_conv2d for more details.

Parameters:
x (tf.Tensor3D|tf.Tensor4D|TypedArray|Array) The input tensor, of rank 4 or rank 3, of shape [batch, height, width, inChannels]. If rank 3, batch of 1 is assumed.
depthwiseFilter (tf.Tensor4D|TypedArray|Array) The depthwise filter tensor, rank 4, of shape [filterHeight, filterWidth, inChannels, channelMultiplier]. This is the filter used in the first step.
pointwiseFilter (tf.Tensor4D|TypedArray|Array) The pointwise filter tensor, rank 4, of shape [1, 1, inChannels * channelMultiplier, outChannels]. This is the filter used in the second step.
strides ([number, number]|number) The strides of the convolution: [strideHeight, strideWidth]. If strides is a single number, then strideHeight == strideWidth.
pad ('valid'|'same') The type of padding algorithm.
same and stride 1: output will be of same size as input, regardless of filter size.
valid: output will be smaller than input if filter is larger than 1x1.
For more info, see this guide: https://www.tensorflow.org/api_docs/python/tf/nn/convolution
dilation ([number, number]|number) Optional
dataFormat ('NHWC'|'NCHW') : An optional string from: "NHWC", "NCHW". Defaults to "NHWC". Specify the data format of the input and output data. With the default format "NHWC", the data is stored in the order of: [batch, height, width, channels]. Only "NHWC" is currently supported. Optional
Returns: tf.Tensor3D|tf.Tensor4D
Operations / Reduction
tf.all (x, axis?, keepDims?) functionSource
Computes the logical and of elements across dimensions of a tf.Tensor.

Reduces the input along the dimensions given in axes. Unless keepDims is true, the rank of the tf.Tensor is reduced by 1 for each entry in axes. If keepDims is true, the reduced dimensions are retained with length 1. If axes has no entries, all dimensions are reduced, and a tf.Tensor with a single element is returned.

const x = tf.tensor1d([1, 1, 1], 'bool');

x.all().print();  // or tf.all(x)
EditRun
const x = tf.tensor2d([1, 1, 0, 0], [2, 2], 'bool');

const axis = 1;
x.all(axis).print();  // or tf.all(x, axis)
EditRun
Parameters:
x (tf.Tensor|TypedArray|Array) The input tensor. Must be of dtype bool.
axis (number|number[]) The dimension(s) to reduce. By default it reduces all dimensions. Optional
keepDims (boolean) If true, retains reduced dimensions with size 1. Optional
Returns: tf.Tensor
tf.any (x, axis?, keepDims?) functionSource
Computes the logical or of elements across dimensions of a tf.Tensor.

Reduces the input along the dimensions given in axes. Unless keepDims is true, the rank of the tf.Tensor is reduced by 1 for each entry in axes. If keepDims is true, the reduced dimensions are retained with length 1. If axes has no entries, all dimensions are reduced, and a tf.Tensor with a single element is returned.

const x = tf.tensor1d([1, 1, 1], 'bool');

x.any().print();  // or tf.any(x)
EditRun
const x = tf.tensor2d([1, 1, 0, 0], [2, 2], 'bool');

const axis = 1;
x.any(axis).print();  // or tf.any(x, axis)
EditRun
Parameters:
x (tf.Tensor|TypedArray|Array) The input tensor. Must be of dtype bool.
axis (number|number[]) The dimension(s) to reduce. By default it reduces all dimensions. Optional
keepDims (boolean) If true, retains reduced dimensions with size 1. Optional
Returns: tf.Tensor
tf.argMax (x, axis?) functionSource
Returns the indices of the maximum values along an axis.

The result has the same shape as input with the dimension along axis removed.

const x = tf.tensor1d([1, 2, 3]);

x.argMax().print();  // or tf.argMax(x)
EditRun
const x = tf.tensor2d([1, 2, 4, 3], [2, 2]);

const axis = 1;
x.argMax(axis).print();  // or tf.argMax(x, axis)
EditRun
Parameters:
x (tf.Tensor|TypedArray|Array) The input tensor.
axis (number) The dimension to reduce. Defaults to 0 (outer-most dimension). Optional
Returns: tf.Tensor
tf.argMin (x, axis?) functionSource
Returns the indices of the minimum values along an axis.

The result has the same shape as input with the dimension along axis removed.

const x = tf.tensor1d([1, 2, 3]);

x.argMin().print();  // or tf.argMin(x)
EditRun
const x = tf.tensor2d([1, 2, 4, 3], [2, 2]);

const axis = 1;
x.argMin(axis).print();  // or tf.argMin(x, axis)
EditRun
Parameters:
x (tf.Tensor|TypedArray|Array) The input tensor.
axis (number) The dimension to reduce. Defaults to 0 (outer-most dimension). Optional
Returns: tf.Tensor
tf.bincount (x, weights, size) functionSource
Outputs a vector with length size and the same dtype as weights.

If weights are empty, then index i stores the number of times the value i is counted in x. If weights are non-empty, then index i stores the sum of the value in weights at each index where the corresponding value in x is i.

Values in x outside of the range [0, size) are ignored.

Parameters:
x (tf.Tensor1D|TypedArray|Array) The input int tensor, rank 1.
weights (tf.Tensor1D|TypedArray|Array) The weights tensor, must have the same shape as x, or a length-0 Tensor, in which case it acts as all weights equal to 1.
size (number) Non-negative integer.
Returns: tf.Tensor1D
tf.denseBincount (x, weights, size, binaryOutput?) functionSource
Outputs a vector with length size and the same dtype as weights.

If weights are empty, then index i stores the number of times the value i is counted in x. If weights are non-empty, then index i stores the sum of the value in weights at each index where the corresponding value in x is i.

Values in x outside of the range [0, size) are ignored.

Parameters:
x (tf.Tensor1D|tf.Tensor2D|TypedArray|Array) The input int tensor, rank 1 or rank 2.
weights (tf.Tensor1D|tf.Tensor2D|TypedArray|Array) The weights tensor, must have the same shape as x, or a length-0 Tensor, in which case it acts as all weights equal to 1.
size (number) Non-negative integer.
binaryOutput (boolean) Optional. Whether the kernel should count the appearance or number of occurrences. Defaults to False. Optional
Returns: tf.Tensor1D|tf.Tensor2D
tf.logSumExp (x, axis?, keepDims?) functionSource
Computes the log(sum(exp(elements across the reduction dimensions))).

Reduces the input along the dimensions given in axis. Unless keepDims is true, the rank of the array is reduced by 1 for each entry in axis. If keepDims is true, the reduced dimensions are retained with length 1. If axis has no entries, all dimensions are reduced, and an array with a single element is returned.

const x = tf.tensor1d([1, 2, 3]);

x.logSumExp().print();  // or tf.logSumExp(x)
EditRun
const x = tf.tensor2d([1, 2, 3, 4], [2, 2]);

const axis = 1;
x.logSumExp(axis).print();  // or tf.logSumExp(a, axis)
EditRun
Parameters:
x (tf.Tensor|TypedArray|Array) The input tensor.
axis (number|number[]) The dimension(s) to reduce. If null (the default), reduces all dimensions. Optional
keepDims (boolean) If true, retains reduced dimensions with length of 1. Defaults to false. Optional
Returns: tf.Tensor
tf.max (x, axis?, keepDims?) functionSource
Computes the maximum of elements across dimensions of a tf.Tensor.

Reduces the input along the dimensions given in axes. Unless keepDims is true, the rank of the tf.Tensor is reduced by 1 for each entry in axes. If keepDims is true, the reduced dimensions are retained with length 1. If axes has no entries, all dimensions are reduced, and a tf.Tensor with a single element is returned.

const x = tf.tensor1d([1, 2, 3]);

x.max().print();  // or tf.max(x)
EditRun
const x = tf.tensor2d([1, 2, 3, 4], [2, 2]);

const axis = 1;
x.max(axis).print();  // or tf.max(x, axis)
EditRun
Parameters:
x (tf.Tensor|TypedArray|Array) The input tensor.
axis (number|number[]) The dimension(s) to reduce. By default it reduces all dimensions. Optional
keepDims (boolean) If true, retains reduced dimensions with size 1. Optional
Returns: tf.Tensor
tf.mean (x, axis?, keepDims?) functionSource
Computes the mean of elements across dimensions of a tf.Tensor.

Reduces x along the dimensions given in axis. Unless keepDims is true, the rank of the tf.Tensor is reduced by 1 for each entry in axis. If keepDims is true, the reduced dimensions are retained with length 1. If axis has no entries, all dimensions are reduced, and a tf.Tensor with a single element is returned.

const x = tf.tensor1d([1, 2, 3]);

x.mean().print();  // or tf.mean(a)
EditRun
const x = tf.tensor2d([1, 2, 3, 4], [2, 2]);

const axis = 1;
x.mean(axis).print();  // or tf.mean(x, axis)
EditRun
Parameters:
x (tf.Tensor|TypedArray|Array) The input tensor.
axis (number|number[]) The dimension(s) to reduce. By default it reduces all dimensions. Optional
keepDims (boolean) If true, retains reduced dimensions with size 1. Optional
Returns: tf.Tensor
tf.min (x, axis?, keepDims?) functionSource
Computes the minimum value from the input.

Reduces the input along the dimensions given in axes. Unless keepDims is true, the rank of the array is reduced by 1 for each entry in axes. If keepDims is true, the reduced dimensions are retained with length 1. If axes has no entries, all dimensions are reduced, and an array with a single element is returned.

const x = tf.tensor1d([1, 2, 3]);

x.min().print();  // or tf.min(x)
EditRun
const x = tf.tensor2d([1, 2, 3, 4], [2, 2]);

const axis = 1;
x.min(axis).print();  // or tf.min(x, axis)
EditRun
Parameters:
x (tf.Tensor|TypedArray|Array) The input Tensor.
axis (number|number[]) The dimension(s) to reduce. By default it reduces all dimensions. Optional
keepDims (boolean) If true, retains reduced dimensions with size 1. Optional
Returns: tf.Tensor
tf.prod (x, axis?, keepDims?) functionSource
Computes the product of elements across dimensions of a tf.Tensor.

Reduces the input along the dimensions given in axes. Unless keepDims is true, the rank of the tf.Tensor is reduced by 1 for each entry in axes. If keepDims is true, the reduced dimensions are retained with length 1. If axes has no entries, all dimensions are reduced, and a tf.Tensor with a single element is returned.

const x = tf.tensor1d([1, 2, 3]);

x.prod().print();  // or tf.prod(x)
EditRun
const x = tf.tensor2d([1, 2, 3, 4], [2, 2]);

const axis = 1;
x.prod(axis).print();  // or tf.prod(x, axis)
EditRun
Parameters:
x (tf.Tensor|TypedArray|Array) The input tensor to compute the product over. If the dtype is bool it will be converted to int32 and the output dtype will be int32.
axis (number|number[]) The dimension(s) to reduce. By default it reduces all dimensions. Optional
keepDims (boolean) If true, retains reduced dimensions with size 1. Optional
Returns: tf.Tensor
tf.sum (x, axis?, keepDims?) functionSource
Computes the sum of elements across dimensions of a tf.Tensor.

Reduces the input along the dimensions given in axes. Unless keepDims is true, the rank of the tf.Tensor is reduced by 1 for each entry in axes. If keepDims is true, the reduced dimensions are retained with length 1. If axes has no entries, all dimensions are reduced, and a tf.Tensor with a single element is returned.

const x = tf.tensor1d([1, 2, 3]);

x.sum().print();  // or tf.sum(x)
EditRun
const x = tf.tensor2d([1, 2, 3, 4], [2, 2]);

const axis = 1;
x.sum(axis).print();  // or tf.sum(x, axis)
EditRun
Parameters:
x (tf.Tensor|TypedArray|Array) The input tensor to compute the sum over. If the dtype is bool it will be converted to int32 and the output dtype will be int32.
axis (number|number[]) The dimension(s) to reduce. By default it reduces all dimensions. Optional
keepDims (boolean) If true, retains reduced dimensions with size 1. Optional
Returns: tf.Tensor
Operations / Normalization
tf.batchNorm (x, mean, variance, offset?, scale?, varianceEpsilon?) functionSource
Batch normalization.

As described in http://arxiv.org/abs/1502.03167.

Mean, variance, scale, and offset can be of two shapes:

The same shape as the input.
In the common case, the depth dimension is the last dimension of x, so the values would be a tf.Tensor1D of shape [depth].
Also available are stricter rank-specific methods with the same signature as this method that assert that parameters passed are of given rank

tf.batchNorm2d
tf.batchNorm3d
tf.batchNorm4d
Parameters:
x (tf.Tensor|TypedArray|Array) The input Tensor.
mean (tf.Tensor|tf.Tensor1D|TypedArray|Array) A mean Tensor.
variance (tf.Tensor|tf.Tensor1D|TypedArray|Array) A variance Tensor.
offset (tf.Tensor|tf.Tensor1D|TypedArray|Array) An offset Tensor. Optional
scale (tf.Tensor|tf.Tensor1D|TypedArray|Array) A scale Tensor. Optional
varianceEpsilon (number) A small float number to avoid dividing by 0. Optional
Returns: tf.Tensor
tf.localResponseNormalization (x, depthRadius?, bias?, alpha?, beta?) functionSource
Normalizes the activation of a local neighborhood across or within channels.

Parameters:
x (tf.Tensor3D|tf.Tensor4D|TypedArray|Array) The input tensor. The 4-D input tensor is treated as a 3-D array of 1D vectors (along the last dimension), and each vector is normalized independently.
depthRadius (number) The number of adjacent channels in the 1D normalization window. Optional
bias (number) A constant bias term for the basis. Optional
alpha (number) A scale factor, usually positive. Optional
beta (number) An exponent. Optional
Returns: tf.Tensor3D|tf.Tensor4D
tf.logSoftmax (logits, axis?) functionSource
Computes the log softmax.

const a = tf.tensor1d([1, 2, 3]);

a.logSoftmax().print();  // or tf.logSoftmax(a)
EditRun
const a = tf.tensor2d([2, 4, 6, 1, 2, 3], [2, 3]);

a.logSoftmax().print();  // or tf.logSoftmax(a)
EditRun
Parameters:
logits (tf.Tensor|TypedArray|Array) The logits array.
axis (number) The dimension softmax would be performed on. Defaults to -1 which indicates the last dimension. Optional
Returns: tf.Tensor
tf.moments (x, axis?, keepDims?) functionSource
Calculates the mean and variance of x. The mean and variance are calculated by aggregating the contents of x across axes. If x is 1-D and axes = [0] this is just the mean and variance of a vector.

Parameters:
x (tf.Tensor|TypedArray|Array) The input tensor.
axis (number|number[]) The dimension(s) along with to compute mean and variance. By default it reduces all dimensions. Optional
keepDims (boolean) If true, the moments have the same dimensionality as the input. Optional
Returns: {mean: tf.Tensor, variance: tf.Tensor}
tf.softmax (logits, dim?) functionSource
Computes the softmax normalized vector given the logits.

const a = tf.tensor1d([1, 2, 3]);

a.softmax().print();  // or tf.softmax(a)
EditRun
const a = tf.tensor2d([2, 4, 6, 1, 2, 3], [2, 3]);

a.softmax().print();  // or tf.softmax(a)
EditRun
Parameters:
logits (tf.Tensor|TypedArray|Array) The logits array.
dim (number) The dimension softmax would be performed on. Defaults to -1 which indicates the last dimension. Optional
Returns: tf.Tensor
tf.sparseToDense (sparseIndices, sparseValues, outputShape, defaultValue?) functionSource
Converts a sparse representation into a dense tensor.

Builds an array dense with shape outputShape such that:

// If sparseIndices is scalar dense[i] = (i == sparseIndices ? sparseValues : defaultValue)

// If sparseIndices is a vector, then for each i dense[sparseIndices[i]] = sparseValues[i]

// If sparseIndices is an n by d matrix, then for each i in [0, n) dense[sparseIndices[i][0], ..., sparseIndices[i][d-1]] = sparseValues[i] All other values in dense are set to defaultValue. If sparseValues is a scalar, all sparse indices are set to this single value.

If indices are repeated the final value is summed over all values for those indices.

const indices = tf.tensor1d([4, 5, 6, 1, 2, 3], 'int32');
const values = tf.tensor1d([10, 11, 12, 13, 14, 15], 'float32');
const shape = [8];
tf.sparseToDense(indices, values, shape).print();
EditRun
Parameters:
sparseIndices (tf.Tensor|TypedArray|Array) A 0-D, 1-D, or 2-D Tensor of type int32. sparseIndices[i] contains the complete index where sparseValues[i] will be placed.
sparseValues (tf.Tensor|TypedArray|Array) A 0-D or 1-D Tensor. Values corresponding to each row of sparseIndices, or a scalar value to be used for all sparse indices.
outputShape (number[]) Shape of the dense output tensor. The type is inferred.
defaultValue (tf.Scalar|ScalarLike) Scalar. Value to set for indices not specified in sparseIndices. Defaults to zero. Optional
Returns: tf.Tensor
Operations / Images
tf.image.cropAndResize (image, boxes, boxInd, cropSize, method?, extrapolationValue?) functionSource
Extracts crops from the input image tensor and resizes them using bilinear sampling or nearest neighbor sampling (possibly with aspect ratio change) to a common output size specified by cropSize.

Parameters:
image (tf.Tensor4D|TypedArray|Array) 4d tensor of shape [batch,imageHeight,imageWidth, depth], where imageHeight and imageWidth must be positive, specifying the batch of images from which to take crops
boxes (tf.Tensor2D|TypedArray|Array) 2d float32 tensor of shape [numBoxes, 4]. Each entry is [y1, x1, y2, x2], where (y1, x1) and (y2, x2) are the normalized coordinates of the box in the boxInd[i]th image in the batch
boxInd (tf.Tensor1D|TypedArray|Array) 1d int32 tensor of shape [numBoxes] with values in range [0, batch) that specifies the image that the i-th box refers to.
cropSize ([number, number]) 1d int32 tensor of 2 elements [cropHeigh, cropWidth] specifying the size to which all crops are resized to.
method ('bilinear'|'nearest') Optional string from 'bilinear' | 'nearest', defaults to bilinear, which specifies the sampling method for resizing Optional
extrapolationValue (number) A threshold for deciding when to remove boxes based on score. Defaults to 0. Optional
Returns: tf.Tensor4D
tf.image.flipLeftRight (image) functionSource
Flips the image left to right. Currently available in the CPU, WebGL, and WASM backends.

Parameters:
image (tf.Tensor4D|TypedArray|Array) 4d tensor of shape [batch, imageHeight, imageWidth, depth].
Returns: tf.Tensor4D
tf.image.grayscaleToRGB (image) functionSource
Converts images from grayscale to RGB format.

Parameters:
image (tf.Tensor2D|tf.Tensor3D|tf.Tensor4D|tf.Tensor5D| tf.Tensor6D|TypedArray|Array) A grayscale tensor to convert. The image's last dimension must be size 1 with at least a two-dimensional shape.
Returns: tf.Tensor2D|tf.Tensor3D|tf.Tensor4D|tf.Tensor5D| tf.Tensor6D
tf.image.nonMaxSuppression (boxes, scores, maxOutputSize, iouThreshold?, scoreThreshold?) functionSource
Performs non maximum suppression of bounding boxes based on iou (intersection over union).

Parameters:
boxes (tf.Tensor2D|TypedArray|Array) a 2d tensor of shape [numBoxes, 4]. Each entry is [y1, x1, y2, x2], where (y1, x1) and (y2, x2) are the corners of the bounding box.
scores (tf.Tensor1D|TypedArray|Array) a 1d tensor providing the box scores of shape [numBoxes].
maxOutputSize (number) The maximum number of boxes to be selected.
iouThreshold (number) A float representing the threshold for deciding whether boxes overlap too much with respect to IOU. Must be between [0, 1]. Defaults to 0.5 (50% box overlap). Optional
scoreThreshold (number) A threshold for deciding when to remove boxes based on score. Defaults to -inf, which means any score is accepted. Optional
Returns: tf.Tensor1D
tf.image.nonMaxSuppressionAsync (boxes, scores, maxOutputSize, iouThreshold?, scoreThreshold?) functionSource
Performs non maximum suppression of bounding boxes based on iou (intersection over union).

This is the async version of nonMaxSuppression

Parameters:
boxes (tf.Tensor2D|TypedArray|Array) a 2d tensor of shape [numBoxes, 4]. Each entry is [y1, x1, y2, x2], where (y1, x1) and (y2, x2) are the corners of the bounding box.
scores (tf.Tensor1D|TypedArray|Array) a 1d tensor providing the box scores of shape [numBoxes].
maxOutputSize (number) The maximum number of boxes to be selected.
iouThreshold (number) A float representing the threshold for deciding whether boxes overlap too much with respect to IOU. Must be between [0, 1]. Defaults to 0.5 (50% box overlap). Optional
scoreThreshold (number) A threshold for deciding when to remove boxes based on score. Defaults to -inf, which means any score is accepted. Optional
Returns: Promise<tf.Tensor1D>
tf.image.nonMaxSuppressionPadded (boxes, scores, maxOutputSize, iouThreshold?, scoreThreshold?, padToMaxOutputSize?) functionSource
Asynchronously performs non maximum suppression of bounding boxes based on iou (intersection over union), with an option to pad results.

Parameters:
boxes (tf.Tensor2D|TypedArray|Array) a 2d tensor of shape [numBoxes, 4]. Each entry is [y1, x1, y2, x2], where (y1, x1) and (y2, x2) are the corners of the bounding box.
scores (tf.Tensor1D|TypedArray|Array) a 1d tensor providing the box scores of shape [numBoxes].
maxOutputSize (number) The maximum number of boxes to be selected.
iouThreshold (number) A float representing the threshold for deciding whether boxes overlap too much with respect to IOU. Must be between [0, 1]. Defaults to 0.5 (50% box overlap). Optional
scoreThreshold (number) A threshold for deciding when to remove boxes based on score. Defaults to -inf, which means any score is accepted. Optional
padToMaxOutputSize (boolean) Defaults to false. If true, size of output selectedIndices is padded to maxOutputSize. Optional
Returns: {[name: string]: tf.Tensor}
tf.image.nonMaxSuppressionPaddedAsync (boxes, scores, maxOutputSize, iouThreshold?, scoreThreshold?, padToMaxOutputSize?) functionSource
Asynchronously performs non maximum suppression of bounding boxes based on iou (intersection over union), with an option to pad results.

Parameters:
boxes (tf.Tensor2D|TypedArray|Array) a 2d tensor of shape [numBoxes, 4]. Each entry is [y1, x1, y2, x2], where (y1, x1) and (y2, x2) are the corners of the bounding box.
scores (tf.Tensor1D|TypedArray|Array) a 1d tensor providing the box scores of shape [numBoxes].
maxOutputSize (number) The maximum number of boxes to be selected.
iouThreshold (number) A float representing the threshold for deciding whether boxes overlap too much with respect to IOU. Must be between [0, 1]. Defaults to 0.5 (50% box overlap). Optional
scoreThreshold (number) A threshold for deciding when to remove boxes based on score. Defaults to -inf, which means any score is accepted. Optional
padToMaxOutputSize (boolean) Defaults to false. If true, size of output selectedIndices is padded to maxOutputSize. Optional
Returns: Promise<{[name: string]: tf.Tensor}>
tf.image.nonMaxSuppressionWithScore (boxes, scores, maxOutputSize, iouThreshold?, scoreThreshold?, softNmsSigma?) functionSource
Performs non maximum suppression of bounding boxes based on iou (intersection over union).

This op also supports a Soft-NMS mode (cf. Bodla et al, https://arxiv.org/abs/1704.04503) where boxes reduce the score of other overlapping boxes, therefore favoring different regions of the image with high scores. To enable this Soft-NMS mode, set the softNmsSigma parameter to be larger than 0.

Parameters:
boxes (tf.Tensor2D|TypedArray|Array) a 2d tensor of shape [numBoxes, 4]. Each entry is [y1, x1, y2, x2], where (y1, x1) and (y2, x2) are the corners of the bounding box.
scores (tf.Tensor1D|TypedArray|Array) a 1d tensor providing the box scores of shape [numBoxes].
maxOutputSize (number) The maximum number of boxes to be selected.
iouThreshold (number) A float representing the threshold for deciding whether boxes overlap too much with respect to IOU. Must be between [0, 1]. Defaults to 0.5 (50% box overlap). Optional
scoreThreshold (number) A threshold for deciding when to remove boxes based on score. Defaults to -inf, which means any score is accepted. Optional
softNmsSigma (number) A float representing the sigma parameter for Soft NMS. When sigma is 0, it falls back to nonMaxSuppression. Optional
Returns: {[name: string]: tf.Tensor}
tf.image.nonMaxSuppressionWithScoreAsync (boxes, scores, maxOutputSize, iouThreshold?, scoreThreshold?, softNmsSigma?) functionSource
Asynchronously performs non maximum suppression of bounding boxes based on iou (intersection over union).

This op also supports a Soft-NMS mode (cf. Bodla et al, https://arxiv.org/abs/1704.04503) where boxes reduce the score of other overlapping boxes, therefore favoring different regions of the image with high scores. To enable this Soft-NMS mode, set the softNmsSigma parameter to be larger than 0.

Parameters:
boxes (tf.Tensor2D|TypedArray|Array) a 2d tensor of shape [numBoxes, 4]. Each entry is [y1, x1, y2, x2], where (y1, x1) and (y2, x2) are the corners of the bounding box.
scores (tf.Tensor1D|TypedArray|Array) a 1d tensor providing the box scores of shape [numBoxes].
maxOutputSize (number) The maximum number of boxes to be selected.
iouThreshold (number) A float representing the threshold for deciding whether boxes overlap too much with respect to IOU. Must be between [0, 1]. Defaults to 0.5 (50% box overlap). Optional
scoreThreshold (number) A threshold for deciding when to remove boxes based on score. Defaults to -inf, which means any score is accepted. Optional
softNmsSigma (number) A float representing the sigma parameter for Soft NMS. When sigma is 0, it falls back to nonMaxSuppression. Optional
Returns: Promise<{[name: string]: tf.Tensor}>
tf.image.resizeBilinear (images, size, alignCorners?, halfPixelCenters?) functionSource
Bilinear resize a single 3D image or a batch of 3D images to a new shape.

Parameters:
images (tf.Tensor3D|tf.Tensor4D|TypedArray|Array) The images, of rank 4 or rank 3, of shape [batch, height, width, inChannels]. If rank 3, batch of 1 is assumed.
size ([number, number]) The new shape [newHeight, newWidth] to resize the images to. Each channel is resized individually.
alignCorners (boolean) Defaults to false. If true, rescale input by (new_height - 1) / (height - 1), which exactly aligns the 4 corners of images and resized images. If false, rescale by new_height / height. Treat similarly the width dimension. Optional
halfPixelCenters (boolean) Defaults to false. Whether to assume pixel centers are at 0.5, which would make the floating point coordinates of the top left pixel 0.5, 0.5. Optional
Returns: tf.Tensor3D|tf.Tensor4D
tf.image.resizeNearestNeighbor (images, size, alignCorners?, halfPixelCenters?) functionSource
NearestNeighbor resize a batch of 3D images to a new shape.

Parameters:
images (tf.Tensor3D|tf.Tensor4D|TypedArray|Array) The images, of rank 4 or rank 3, of shape [batch, height, width, inChannels]. If rank 3, batch of 1 is assumed.
size ([number, number]) The new shape [newHeight, newWidth] to resize the images to. Each channel is resized individually.
alignCorners (boolean) Defaults to False. If true, rescale input by (new_height - 1) / (height - 1), which exactly aligns the 4 corners of images and resized images. If false, rescale by new_height / height. Treat similarly the width dimension. Optional
halfPixelCenters (boolean) Defaults to false. Whether to assume pixels are of half the actual dimensions, and yield more accurate resizes. This flag would also make the floating point coordinates of the top left pixel 0.5, 0.5. Optional
Returns: tf.Tensor3D|tf.Tensor4D
tf.image.rgbToGrayscale (image) functionSource
Converts images from RGB format to grayscale.

Parameters:
image (tf.Tensor2D|tf.Tensor3D|tf.Tensor4D|tf.Tensor5D| tf.Tensor6D|TypedArray|Array) A RGB tensor to convert. The image's last dimension must be size 3 with at least a two-dimensional shape.
Returns: tf.Tensor2D|tf.Tensor3D|tf.Tensor4D|tf.Tensor5D| tf.Tensor6D
tf.image.rotateWithOffset (image, radians, fillValue?, center?) functionSource
Rotates the input image tensor counter-clockwise with an optional offset center of rotation. Currently available in the CPU, WebGL, and WASM backends.

Parameters:
image (tf.Tensor4D|TypedArray|Array) 4d tensor of shape [batch, imageHeight, imageWidth, depth].
radians (number) The amount of rotation.
fillValue (number|[number, number, number]) The value to fill in the empty space leftover after rotation. Can be either a single grayscale value (0-255), or an array of three numbers [red, green, blue] specifying the red, green, and blue channels. Defaults to 0 (black). Optional
center (number|[number, number]) The center of rotation. Can be either a single value (0-1), or an array of two numbers [centerX, centerY]. Defaults to 0.5 (rotates the image around its center). Optional
Returns: tf.Tensor4D
tf.image.transform (image, transforms, interpolation?, fillMode?, fillValue?, outputShape?) functionSource
Applies the given transform(s) to the image(s).

Parameters:
image (tf.Tensor4D|TypedArray|Array) 4d tensor of shape [batch, imageHeight, imageWidth, depth].
transforms (tf.Tensor2D|TypedArray|Array) Projective transform matrix/matrices. A tensor1d of length 8 or tensor of size N x 8. If one row of transforms is [a0, a1, a2, b0, b1, b2, c0, c1], then it maps the output point (x, y) to a transformed input point (x', y') = ((a0 x + a1 y + a2) / k, (b0 x + b1 y + b2) / k), where k = c0 x + c1 y + 1. The transforms are inverted compared to the transform mapping input points to output points.
interpolation ('nearest'|'bilinear') Interpolation mode. Supported values: 'nearest', 'bilinear'. Default to 'nearest'. Optional
fillMode ('constant'|'reflect'|'wrap'|'nearest') Points outside the boundaries of the input are filled according to the given mode, one of 'constant', 'reflect', 'wrap', 'nearest'. Default to 'constant'. 'reflect': (d c b a | a b c d | d c b a ) The input is extended by reflecting about the edge of the last pixel. 'constant': (k k k k | a b c d | k k k k) The input is extended by filling all values beyond the edge with the same constant value k. 'wrap': (a b c d | a b c d | a b c d) The input is extended by wrapping around to the opposite edge. 'nearest': (a a a a | a b c d | d d d d) The input is extended by the nearest pixel. Optional
fillValue (number) A float represents the value to be filled outside the boundaries when fillMode is 'constant'. Optional
outputShape ([number, number]) Optional
Returns: tf.Tensor4D
Operations / RNN
tf.basicLSTMCell (forgetBias, lstmKernel, lstmBias, data, c, h) functionSource
Computes the next state and output of a BasicLSTMCell.

Returns [newC, newH].

Derived from tf.contrib.rnn.BasicLSTMCell.

Parameters:
forgetBias (tf.Scalar|TypedArray|Array) Forget bias for the cell.
lstmKernel (tf.Tensor2D|TypedArray|Array) The weights for the cell.
lstmBias (tf.Tensor1D|TypedArray|Array) The bias for the cell.
data (tf.Tensor2D|TypedArray|Array) The input to the cell.
c (tf.Tensor2D|TypedArray|Array) Previous cell state.
h (tf.Tensor2D|TypedArray|Array) Previous cell output.
Returns: [tf.Tensor2D, tf.Tensor2D]
tf.multiRNNCell (lstmCells, data, c, h) functionSource
Computes the next states and outputs of a stack of LSTMCells.

Each cell output is used as input to the next cell.

Returns [cellState, cellOutput].

Derived from tf.contrib.rn.MultiRNNCell.

Parameters:
lstmCells ((data: tf.Tensor2D, c: tf.Tensor2D, h: tf.Tensor2D): [tf.Tensor2D, tf.Tensor2D][]) Array of LSTMCell functions.
data (tf.Tensor2D|TypedArray|Array) The input to the cell.
c (Array) Array of previous cell states.
h (Array) Array of previous cell outputs.
Returns: [tf.Tensor2D[], tf.Tensor2D[]]
Operations / Logical
tf.bitwiseAnd (x, y) functionSource
Bitwise AND operation for input tensors.

Given two input tensors, returns a new tensor with the AND calculated values.

The method supports int32 values

const x = tf.tensor1d([0, 5, 3, 14], 'int32');
const y = tf.tensor1d([5, 0, 7, 11], 'int32');
tf.bitwiseAnd(x, y).print();
EditRun
Parameters:
x (tf.Tensor) The input tensor to be calculated.
y (tf.Tensor) The input tensor to be calculated.
Returns: tf.Tensor
tf.equal (a, b) functionSource
Returns the truth value of (a == b) element-wise. Supports broadcasting.

const a = tf.tensor1d([1, 2, 3]);
const b = tf.tensor1d([2, 2, 2]);

a.equal(b).print();
EditRun
Parameters:
a (tf.Tensor|TypedArray|Array) The first input tensor.
b (tf.Tensor|TypedArray|Array) The second input tensor. Must have the same dtype as a.
Returns: tf.Tensor
tf.greater (a, b) functionSource
Returns the truth value of (a > b) element-wise. Supports broadcasting.

const a = tf.tensor1d([1, 2, 3]);
const b = tf.tensor1d([2, 2, 2]);

a.greater(b).print();
EditRun
Parameters:
a (tf.Tensor|TypedArray|Array) The first input tensor.
b (tf.Tensor|TypedArray|Array) The second input tensor. Must have the same dtype as a.
Returns: tf.Tensor
tf.greaterEqual (a, b) functionSource
Returns the truth value of (a >= b) element-wise. Supports broadcasting.

const a = tf.tensor1d([1, 2, 3]);
const b = tf.tensor1d([2, 2, 2]);

a.greaterEqual(b).print();
EditRun
Parameters:
a (tf.Tensor|TypedArray|Array) The first input tensor.
b (tf.Tensor|TypedArray|Array) The second input tensor. Must have the same dtype as a.
Returns: tf.Tensor
tf.less (a, b) functionSource
Returns the truth value of (a < b) element-wise. Supports broadcasting.

const a = tf.tensor1d([1, 2, 3]);
const b = tf.tensor1d([2, 2, 2]);

a.less(b).print();
EditRun
Parameters:
a (tf.Tensor|TypedArray|Array) The first input tensor.
b (tf.Tensor|TypedArray|Array) The second input tensor. Must have the same dtype as a.
Returns: tf.Tensor
tf.lessEqual (a, b) functionSource
Returns the truth value of (a <= b) element-wise. Supports broadcasting.

const a = tf.tensor1d([1, 2, 3]);
const b = tf.tensor1d([2, 2, 2]);

a.lessEqual(b).print();
EditRun
Parameters:
a (tf.Tensor|TypedArray|Array) The first input tensor.
b (tf.Tensor|TypedArray|Array) The second input tensor. Must have the same dtype as a.
Returns: tf.Tensor
tf.logicalAnd (a, b) functionSource
Returns the truth value of a AND b element-wise. Supports broadcasting.

const a = tf.tensor1d([false, false, true, true], 'bool');
const b = tf.tensor1d([false, true, false, true], 'bool');

a.logicalAnd(b).print();
EditRun
Parameters:
a (tf.Tensor|TypedArray|Array) The first input tensor. Must be of dtype bool.
b (tf.Tensor|TypedArray|Array) The second input tensor. Must be of dtype bool.
Returns: tf.Tensor
tf.logicalNot (x) functionSource
Returns the truth value of NOT x element-wise.

const a = tf.tensor1d([false, true], 'bool');

a.logicalNot().print();
EditRun
Parameters:
x (tf.Tensor|TypedArray|Array) The input tensor. Must be of dtype 'bool'.
Returns: tf.Tensor
tf.logicalOr (a, b) functionSource
Returns the truth value of a OR b element-wise. Supports broadcasting.

const a = tf.tensor1d([false, false, true, true], 'bool');
const b = tf.tensor1d([false, true, false, true], 'bool');

a.logicalOr(b).print();
EditRun
Parameters:
a (tf.Tensor|TypedArray|Array) The first input tensor. Must be of dtype bool.
b (tf.Tensor|TypedArray|Array) The second input tensor. Must be of dtype bool.
Returns: tf.Tensor
tf.logicalXor (a, b) functionSource
Returns the truth value of a XOR b element-wise. Supports broadcasting.

const a = tf.tensor1d([false, false, true, true], 'bool');
const b = tf.tensor1d([false, true, false, true], 'bool');

a.logicalXor(b).print();
EditRun
Parameters:
a (tf.Tensor|TypedArray|Array) The first input tensor. Must be of dtype bool.
b (tf.Tensor|TypedArray|Array) The second input tensor. Must be of dtype bool.
Returns: tf.Tensor
tf.notEqual (a, b) functionSource
Returns the truth value of (a != b) element-wise. Supports broadcasting.

const a = tf.tensor1d([1, 2, 3]);
const b = tf.tensor1d([0, 2, 3]);

a.notEqual(b).print();
EditRun
Parameters:
a (tf.Tensor|TypedArray|Array) The first input tensor.
b (tf.Tensor|TypedArray|Array) The second input tensor. Must have the same dtype as a.
Returns: tf.Tensor
tf.where (condition, a, b) functionSource
Returns the elements, either a or b depending on the condition.

If the condition is true, select from a, otherwise select from b.

const cond = tf.tensor1d([false, false, true], 'bool');
const a = tf.tensor1d([1 , 2, 3]);
const b = tf.tensor1d([-1, -2, -3]);

a.where(cond, b).print();
EditRun
Parameters:
condition (tf.Tensor|TypedArray|Array) The input condition. Must be of dtype bool.
a (tf.Tensor|TypedArray|Array) If condition is rank 1, a may have a higher rank but its first dimension must match the size of condition.
b (tf.Tensor|TypedArray|Array) A tensor with the same dtype as a and with shape that is compatible with a.
Returns: tf.Tensor
tf.whereAsync (condition) functionSource
Returns the coordinates of true elements of condition.

The coordinates are returned in a 2-D tensor where the first dimension (rows) represents the number of true elements, and the second dimension (columns) represents the coordinates of the true elements. Keep in mind, the shape of the output tensor can vary depending on how many true values there are in input. Indices are output in row-major order. The resulting tensor has the shape [numTrueElems, condition.rank].

This is analogous to calling the python tf.where(cond) without an x or y.

const cond = tf.tensor1d([false, false, true], 'bool');
const result = await tf.whereAsync(cond);
result.print();
EditRun
Parameters:
condition (tf.Tensor|TypedArray|Array)
Returns: Promise<tf.Tensor2D>
Operations / Scan
tf.cumprod (x, axis?, exclusive?, reverse?) functionSource
Computes the cumulative product of a tf.Tensor along axis.

const x = tf.tensor([1, 2, 3, 4]);
x.cumprod().print();
EditRun
const x = tf.tensor([[1, 2], [3, 4]]);
x.cumprod().print();
EditRun
Parameters:
x (tf.Tensor | TypedArray|Array) The input tensor to cumulatively multiply.
axis (number) The axis along which to multiply. Optional. Defaults to 0. Optional
exclusive (boolean) Whether to perform exclusive cumulative product. Optional. Defaults to false. If set to true then the product of each tensor entry does not include its own value, but only the values previous to it along the specified axis. Optional
reverse (boolean) Whether to multiply in the opposite direction. Optional. Defaults to false. Optional
Returns: tf.Tensor
tf.cumsum (x, axis?, exclusive?, reverse?) functionSource
Computes the cumulative sum of a tf.Tensor along axis.

const x = tf.tensor([1, 2, 3, 4]);
x.cumsum().print();
EditRun
const x = tf.tensor([[1, 2], [3, 4]]);
x.cumsum().print();
EditRun
Parameters:
x (tf.Tensor|TypedArray|Array) The input tensor to be summed.
axis (number) The axis along which to sum. Optional. Defaults to 0. Optional
exclusive (boolean) Whether to perform exclusive cumulative sum. Optional. Defaults to false. If set to true then the sum of each tensor entry does not include its own value, but only the values previous to it along the specified axis. Optional
reverse (boolean) Whether to sum in the opposite direction. Optional. Defaults to false. Optional
Returns: tf.Tensor
Operations / Evaluation
tf.confusionMatrix (labels, predictions, numClasses) functionSource
Computes the confusion matrix from true labels and predicted labels.

const labels = tf.tensor1d([0, 1, 2, 1, 0], 'int32');
const predictions = tf.tensor1d([0, 2, 2, 1, 0], 'int32');
const numClasses = 3;
const out = tf.math.confusionMatrix(labels, predictions, numClasses);
out.print();
// Expected output matrix:
// [[2, 0, 0],
//  [0, 1, 1],
//  [0, 0, 1]]
EditRun
Parameters:
labels (tf.Tensor1D|TypedArray|Array) The target labels, assumed to be 0-based integers for the classes. The shape is [numExamples], where numExamples is the number of examples included.
predictions (tf.Tensor1D|TypedArray|Array) The predicted classes, assumed to be 0-based integers for the classes. Must have the same shape as labels.
numClasses (number) Number of all classes, as an integer. Its value must be larger than the largest element in labels and predictions.
Returns: tf.Tensor2D
tf.inTopKAsync (predictions, targets, k?) functionSource
Returns whether the targets are in the top K predictions.

const predictions = tf.tensor2d([[20, 10, 40, 30], [30, 50, -20, 10]]);
const targets = tf.tensor1d([2, 0]);
const precision = await tf.inTopKAsync(predictions, targets);
precision.print();
EditRun
Parameters:
predictions (tf.Tensor|TypedArray|Array) 2-D or higher tf.Tensor with last dimension being at least k.
targets (tf.Tensor|TypedArray|Array) 1-D or higher tf.Tensor.
k (number) Optional Number of top elements to look at for computing precision, default to 1. Optional
Returns: Promise<tf.Tensor>
tf.lowerBound (sortedSequence, values) functionSource
Searches for where a value would go in a sorted sequence.

This is not a method for checking containment (like javascript in).

The typical use case for this operation is "binning", "bucketing", or "discretizing". The values are assigned to bucket-indices based on the edges listed in 'sortedSequence'. This operation returns the bucket-index for each value.

The index returned corresponds to the first edge greater than or equal to the value.

The axis is not settable for this operation. It always operates on the innermost dimension (axis=-1). The operation will accept any number of outer dimensions.

Note: This operation assumes that 'lowerBound' is sorted along the innermost axis, maybe using 'sort(..., axis=-1)'. If the sequence is not sorted no error is raised and the content of the returned tensor is not well defined.

const edges = tf.tensor1d([-1, 3.3, 9.1, 10.0]);
let values = tf.tensor1d([0.0, 4.1, 12.0]);
const result1 = tf.lowerBound(edges, values);
result1.print(); // [1, 2, 4]

const seq = tf.tensor1d([0, 3, 9, 10, 10]);
values = tf.tensor1d([0, 4, 10]);
const result2 = tf.lowerBound(seq, values);
result2.print(); // [0, 2, 3]

const sortedSequence = tf.tensor2d([[0., 3., 8., 9., 10.],
                                     [1., 2., 3., 4., 5.]]);
values = tf.tensor2d([[9.8, 2.1, 4.3],
                       [0.1, 6.6, 4.5, ]]);
const result3 = tf.lowerBound(sortedSequence, values);
result3.print(); // [[4, 1, 2], [0, 5, 4]]
EditRun
Parameters:
sortedSequence (tf.Tensor|TypedArray|Array) : N-D. Sorted sequence.
values (tf.Tensor|TypedArray|Array) : N-D. Search values.
Returns: tf.Tensor
tf.searchSorted (sortedSequence, values, side?) functionSource
Searches for where a value would go in a sorted sequence.

This is not a method for checking containment (like javascript in).

The typical use case for this operation is "binning", "bucketing", or "discretizing". The values are assigned to bucket-indices based on the edges listed in 'sortedSequence'. This operation returns the bucket-index for each value.

The side argument controls which index is returned if a value lands exactly on an edge.

The axis is not settable for this operation. It always operates on the innermost dimension (axis=-1). The operation will accept any number of outer dimensions.

Note: This operation assumes that 'sortedSequence' is sorted along the innermost axis, maybe using 'sort(..., axis=-1)'. If the sequence is not sorted no error is raised and the content of the returned tensor is not well defined.

const edges = tf.tensor1d([-1, 3.3, 9.1, 10.0]);
let values = tf.tensor1d([0.0, 4.1, 12.0]);
const result1 = tf.searchSorted(edges, values, 'left');
result1.print(); // [1, 2, 4]

const seq = tf.tensor1d([0, 3, 9, 10, 10]);
values = tf.tensor1d([0, 4, 10]);
const result2 = tf.searchSorted(seq, values, 'left');
result2.print(); // [0, 2, 3]
const result3 = tf.searchSorted(seq, values, 'right');
result3.print(); // [1, 2, 5]

const sortedSequence = tf.tensor2d([[0., 3., 8., 9., 10.],
                                     [1., 2., 3., 4., 5.]]);
values = tf.tensor2d([[9.8, 2.1, 4.3],
                       [0.1, 6.6, 4.5, ]]);
const result4 = tf.searchSorted(sortedSequence, values, 'left');
result4.print(); // [[4, 1, 2], [0, 5, 4]]
EditRun
Parameters:
sortedSequence (tf.Tensor|TypedArray|Array) : N-D. Sorted sequence.
values (tf.Tensor|TypedArray|Array) : N-D. Search values.
side ('left'|'right') : 'left'|'right'. Defaults to 'left'. 'left' corresponds to lower bound and 'right' to upper bound. Optional
Returns: tf.Tensor
tf.topk (x, k?, sorted?) functionSource
Finds the values and indices of the k largest entries along the last dimension.

If the input is a vector (rank=1), finds the k largest entries in the vector and outputs their values and indices as vectors. Thus values[j] is the j-th largest entry in input, and its index is indices[j]. For higher rank inputs, computes the top k entries along the last dimension.

If two elements are equal, the lower-index element appears first.

const a = tf.tensor2d([[1, 5], [4, 3]]);
const {values, indices} = tf.topk(a);
values.print();
indices.print();
EditRun
Parameters:
x (tf.Tensor|TypedArray|Array) 1-D or higher tf.Tensor with last dimension being at least k.
k (number) Number of top elements to look for along the last dimension. Optional
sorted (boolean) If true, the resulting k elements will be sorted by the values in descending order. Optional
Returns: {values: tf.Tensor, indices: tf.Tensor}
tf.unique (x, axis?) functionSource
Finds unique elements along an axis of a tensor.

It returns a tensor values containing all of the unique elements along the axis of the given tensor x in the same order that they occur along the axis in x; x does not need to be sorted. It also returns a tensor indices the same size as the number of the elements in x along the axis dimension. It contains the index in the unique output values.

// A 1-D tensor
const a = tf.tensor1d([1, 1, 2, 4, 4, 4, 7, 8, 8]);
const {values, indices} = tf.unique(a);
values.print();   // [1, 2, 4, 7, 8,]
indices.print();  // [0, 0, 1, 2, 2, 2, 3, 4, 4]
EditRun
// A 2-D tensor with axis=0
//
// 'a' is: [[1, 0, 0],
//          [1, 0, 0],
//          [2, 0, 0]]
const a = tf.tensor2d([[1, 0, 0], [1, 0, 0], [2, 0, 0]]);
const {values, indices} = tf.unique(a, 0)
values.print();   // [[1, 0, 0],
                   //  [2, 0, 0]]
indices.print();  // [0, 0, 1]
EditRun
// A 2-D tensor with axis=1
//
// 'a' is: [[1, 0, 0],
//          [1, 0, 0],
//          [2, 0, 0]]
const a = tf.tensor2d([[1, 0, 0], [1, 0, 0], [2, 0, 0]]);
const {values, indices} = tf.unique(a, 1)
values.print();   // [[1, 0],
                   //  [1, 0],
                   //  [2, 0]]
indices.print();  // [0, 1, 1]
EditRun
Parameters:
x (tf.Tensor|TypedArray|Array) A tensor (int32, string, bool).
axis (number) The axis of the tensor to find the unique elements. Optional
Returns: {values: tf.Tensor, indices: tf.Tensor1D}
tf.upperBound (sortedSequence, values) functionSource
Searches for where a value would go in a sorted sequence.

This is not a method for checking containment (like javascript in).

The typical use case for this operation is "binning", "bucketing", or "discretizing". The values are assigned to bucket-indices based on the edges listed in 'sortedSequence'. This operation returns the bucket-index for each value.

The index returned corresponds to the first edge greater than the value.

The axis is not settable for this operation. It always operates on the innermost dimension (axis=-1). The operation will accept any number of outer dimensions.

Note: This operation assumes that 'upperBound' is sorted along the innermost axis, maybe using 'sort(..., axis=-1)'. If the sequence is not sorted no error is raised and the content of the returned tensor is not well defined.

const seq = tf.tensor1d([0, 3, 9, 10, 10]);
const values = tf.tensor1d([0, 4, 10]);
const result = tf.upperBound(seq, values);
result.print(); // [1, 2, 5]
EditRun
Parameters:
sortedSequence (tf.Tensor|TypedArray|Array) : N-D. Sorted sequence.
values (tf.Tensor|TypedArray|Array) : N-D. Search values.
Returns: tf.Tensor
Operations / Slicing and Joining
tf.gatherND (x, indices) functionSource
Gather slices from input tensor into a Tensor with shape specified by indices.

indices is a K-dimensional integer tensor, best thought of as a (K-1)-dimensional tensor of indices into input, where each element defines a slice of input: output[\(i_0, ..., i_{K-2}\)] = input[indices[\(i_0, ..., i_{K-2}\)]]

Whereas in tf.gather(), indices defines slices into the first dimension of input, in tf.gatherND(), indices defines slices into the first N dimensions of input, where N = indices.shape[-1].

The last dimension of indices can be at most the rank of input: indices.shape[-1] <= input.rank

The last dimension of indices corresponds to elements (if indices.shape[-1] == input.rank) or slices (if indices.shape[-1] < input.rank) along dimension indices.shape[-1] of input. The output tensor has shape indices.shape[:-1] + input.shape[indices.shape[-1]:]

Note that on CPU, if an out of bound index is found, an error is returned. On GPU, if an out of bound index is found, a 0 is stored in the corresponding output value.

const indices = tf.tensor2d([0, 1, 1, 0], [2,2], 'int32');
const input = tf.tensor2d([9, 10, 11, 12], [2, 2]);
tf.gatherND(input, indices).print() // [10, 11]
EditRun
Parameters:
x (tf.Tensor|TypedArray|Array) The tensor from which to gather values.
indices (tf.Tensor|TypedArray|Array) Index tensor, must be of type int32.
Returns: tf.Tensor
tf.meshgrid (x?, y?, __2?) functionSource
Broadcasts parameters for evaluation on an N-D grid.

Given N one-dimensional coordinate arrays *args, returns a list outputs of N-D coordinate arrays for evaluating expressions on an N-D grid.

Notes: meshgrid supports cartesian ('xy') and matrix ('ij') indexing conventions. When the indexing argument is set to 'xy' (the default), the broadcasting instructions for the first two dimensions are swapped. Examples: Calling const [X, Y] = meshgrid(x, y) with the tensors

const x = [1, 2, 3];
const y = [4, 5, 6];
const [X, Y] = tf.meshgrid(x, y);
// X = [[1, 2, 3],
//      [1, 2, 3],
//      [1, 2, 3]]
// Y = [[4, 4, 4],
//      [5, 5, 5],
//      [6, 6, 6]]
Parameters:
x (tf.Tensor|TypedArray|Array) Tensor with rank geq 1. Optional
y (tf.Tensor|TypedArray|Array) Tensor with rank geq 1. Optional
__2 ({ indexing?: string; }) Optional
Returns: tf.Tensor[]
tf.scatterND (indices, updates, shape) functionSource
Creates a new tensor by applying sparse updates to individual values or slices within a zero tensor of the given shape tensor according to indices. This operator is the inverse of the tf.gatherND() operator which extracts values or slices from a given tensor.

const indices = tf.tensor2d([4, 3, 1, 7], [4, 1], 'int32');
const updates = tf.tensor1d([9, 10, 11, 12]);
const shape = [8];
tf.scatterND(indices, updates, shape).print() //[0, 11, 0, 10, 9, 0, 0, 12]
EditRun
Parameters:
indices (tf.Tensor|TypedArray|Array) The tensor contains the indices into the output tensor.
updates (tf.Tensor|TypedArray|Array) The tensor contains the value for the indices.
shape (number[]) : The shape of the output tensor.
Returns: tf.Tensor
tf.stridedSlice (x, begin, end, strides?, beginMask?, endMask?, ellipsisMask?, newAxisMask?, shrinkAxisMask?) functionSource
Extracts a strided slice of a tensor.

Roughly speaking, this op extracts a slice of size (end-begin)/stride from the given input tensor (x). Starting at the location specified by begin the slice continues by adding stride to the index until all dimensions are not less than end. Note that a stride can be negative, which causes a reverse slice.

const t = tf.tensor3d([1, 1, 1 ,2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6],
    [3, 2, 3]);
t.stridedSlice([1, 0, 0], [2, 1, 3], [1, 1, 1]).print()  // [[[3, 3, 3]]]
t.stridedSlice([1, 0, 0], [2, 2, 3], [1, 1, 1]).print()  // [[[3, 3, 3],
                                                     // [4, 4, 4]]]
t.stridedSlice([1, -1, 0], [2, -3, 3], [1, -1, 1]).print() // [[[4, 4, 4],
                                                     // [3, 3, 3]]]
EditRun
Parameters:
x (tf.Tensor|TypedArray|Array) The tensor to stride slice.
begin (number[]) The coordinates to start the slice from.
end (number[]) : The coordinates to end the slice at.
strides (number[]) : The size of the slice. Optional
beginMask (number) : If the ith bit of beginMask is set, begin[i] is ignored and the fullest possible range in that dimension is used instead. Optional
endMask (number) : If the ith bit of endMask is set, end[i] is ignored and the fullest possible range in that dimension is used instead. Optional
ellipsisMask (number) Optional
newAxisMask (number) Optional
shrinkAxisMask (number) : a bitmask where bit i implies that the ith specification should shrink the dimensionality. begin and end must imply a slice of size 1 in the dimension. Optional
Returns: tf.Tensor
tf.tensorScatterUpdate (tensor, indices, updates) functionSource
Creates a new tensor by applying sparse updates to individual values or slices to the passed in tensor according to indices. This operator is the similar to scatterNd op, except that the udpates are scattered on an existing tensor (as opposed to a zero-tensor).

If indices contains duplicates, then we pick the last update for the index.

If an out of bound index is found on CPU, an error is returned.

Warning: There are some GPU specific semantics for this operation.

If an out of bound index is found, the index is ignored.
The order in which updates are applied is nondeterministic, so the output will be nondeterministic if indices contains duplicates.
const shape = [8];
const tensor = tf.ones(shape);
const indices = tf.tensor2d([4, 3, 1, 7], [4, 1], 'int32');
const updates = tf.tensor1d([9, 10, 11, 12]);

tf.tensorScatterUpdate(tensor, indices, updates).print();
    //[1, 11, 1, 10, 9, 1, 1, 12]
EditRun
Parameters:
tensor (tf.Tensor|TypedArray|Array) A Tensor. Tensor to copy/update.
indices (tf.Tensor|TypedArray|Array) The tensor contains the indices into the output tensor, must have at least 2 axes: (num_updates, index_depth).
updates (tf.Tensor|TypedArray|Array) The tensor contains the value for the indices.
Returns: tf.Tensor
Operations / Ragged
tf.raggedTensorToTensor (shape, values, defaultValue, rowPartitionTensors, rowPartitionTypes) functionSource
Create a dense tensor from a ragged tensor, possibly altering its shape.

The raggedTensorToTensor op creates a dense tensor from am array of row partition tensors, a value vector, and default values. If the shape is unspecified, the minimal shape required to contain all the elements in the ragged tensor (the natural shape) will be used. If some dimensions are left unspecified, then the size of the natural shape is used in that dimension.

The defaultValue will be broadcast to the output shape. After that, the values from the ragged tensor overwrite the default values. Note that the defaultValue must have less dimensions than the value.

The row partition tensors are in the order of the dimensions. At present, the types can be: "ROW_SPLITS": the row_splits tensor from the ragged tensor. "VALUE_ROWIDS": the value_rowids tensor from the ragged tensor. "FIRST_DIM_SIZE": if value_rowids is used for the first dimension, then it is preceded by "FIRST_DIM_SIZE".

Parameters:
shape (tf.Tensor|TypedArray|Array) : A Tensor. Must be one of the following types: 'int32'. The desired shape of the output tensor. If left unspecified (empty), the minimal shape required to contain all the elements in the ragged tensor (the natural shape) will be used. If some dimensions are left unspecified, then the size of the natural shape is used in that dimension.
Note that dense dimensions cannot be modified by the shape argument. Trying to change the size of a dense dimension will cause the op to fail. Examples: natural shape: [4, 5, 6] shape: -1 output shape: [4, 5, 6]

natural shape: [4, 5, 6] shape: [3, -1, 2] output shape: [3, 5, 2]

natural shape: [4, 5, 6] shape: [3, 7, 2] output shape: [3, 7, 2]

values (tf.Tensor|TypedArray|Array) : A Tensor. A 1D tensor representing the values of the ragged tensor.
defaultValue (tf.Tensor|TypedArray|Array) : A Tensor. Must have the same type as values. The defaultValue when the shape is larger than the ragged tensor. The defaultValue is broadcast until it is the shape of the output tensor, and then overwritten by values in the ragged tensor. The default value must be compatible with this broadcast operation, and must have fewer dimensions than the value tensor.
rowPartitionTensors (tf.Tensor[]) : A list of at least 1 Tensor objects with the same type in: 'int32'.
rowPartitionTypes (string[]) : A list of strings. The types of the row partition tensors. At present, these can be: "ROW_SPLITS": the row_splits tensor from the ragged tensor. "VALUE_ROWIDS": the value_rowids tensor from the ragged tensor. "FIRST_DIM_SIZE": if value_rowids is used for the first dimension, then it is preceded by "FIRST_DIM_SIZE". The tensors are in the order of the dimensions.
Returns: tf.Tensor
Operations / Spectral
tf.spectral.fft (input) functionSource
Fast Fourier transform.

Computes the 1-dimensional discrete Fourier transform over the inner-most dimension of input.

const real = tf.tensor1d([1, 2, 3]);
const imag = tf.tensor1d([1, 2, 3]);
const x = tf.complex(real, imag);

x.fft().print();  // tf.spectral.fft(x).print();
EditRun
Parameters:
input (tf.Tensor) The complex input to compute an fft over.
Returns: tf.Tensor
tf.spectral.ifft (input) functionSource
Inverse fast Fourier transform.

Computes the inverse 1-dimensional discrete Fourier transform over the inner-most dimension of input.

const real = tf.tensor1d([1, 2, 3]);
const imag = tf.tensor1d([1, 2, 3]);
const x = tf.complex(real, imag);

x.ifft().print();  // tf.spectral.ifft(x).print();
EditRun
Parameters:
input (tf.Tensor) The complex input to compute an ifft over.
Returns: tf.Tensor
tf.spectral.irfft (input) functionSource
Inversed real value input fast Fourier transform.

Computes the 1-dimensional inversed discrete Fourier transform over the inner-most dimension of the real input.

const real = tf.tensor1d([1, 2, 3]);
const imag = tf.tensor1d([0, 0, 0]);
const x = tf.complex(real, imag);

x.irfft().print();
EditRun
Parameters:
input (tf.Tensor) The real value input to compute an irfft over.
Returns: tf.Tensor
tf.spectral.rfft (input, fftLength?) functionSource
Real value input fast Fourier transform.

Computes the 1-dimensional discrete Fourier transform over the inner-most dimension of the real input.

const real = tf.tensor1d([1, 2, 3]);

real.rfft().print();
EditRun
Parameters:
input (tf.Tensor) The real value input to compute an rfft over.
fftLength (number) Optional
Returns: tf.Tensor
Operations / Segment
tf.unsortedSegmentSum (x, segmentIds, numSegments) functionSource
Computes the sum along segments of a tf.Tensor.

const x = tf.tensor1d([1, 2, 3, 4]);
const segmentIds = tf.tensor1d([1, 2, 0, 1], 'int32');
const numSegments = 3;

x.unsortedSegmentSum(segmentIds, numSegments).print()
//or tf.unsortedSegmentSum(x, segmentIds, numSegments)
EditRun
Parameters:
x (tf.Tensor|TypedArray|Array) The tf.Tensor that will be summed along its segments.
segmentIds (tf.Tensor1D|TypedArray|Array) A tf.Tensor1D whose rank is equal to the rank of x's dimension along the axis. Maps each element of x to a segment.
numSegments (number) The number of distinct segmentIds.
Returns: tf.Tensor
Operations / Moving Average
tf.movingAverage (v, x, decay, step?, zeroDebias?) functionSource
Compute the moving average of a variable.

Without zeroDebias, the moving average operation is defined by: v += delta where delta = (1 - decay) * (x - v)

With zeroDebias (default), the delta term is scaled to debias the effect of the (assumed) zero-initialization of v. delta /= (1 - decay ^ step)

For more details on the zero-debiasing algorithm, see: https://arxiv.org/abs/1412.6980

Note that this function is completely stateless and does not keep track of step count. The step count needs to be maintained by the caller and passed in as step.

Parameters:
v (tf.Tensor|TypedArray|Array) The current moving average value.
x (tf.Tensor|TypedArray|Array) New input value, must have the same shape and dtype as v.
decay (number|tf.Scalar) The decay factor. Typical values are 0.95 and 0.99.
step (number|tf.Scalar) Step count. Optional
zeroDebias (boolean) : Whether zeroDebias is to be performed (default: true). Optional
Returns: tf.Tensor
Operations / Dropout
tf.dropout (x, rate, noiseShape?, seed?) functionSource
Computes dropout.

const x = tf.tensor1d([1, 2, 2, 1]);
const rate = 0.75;
const output = tf.dropout(x, rate);
output.print();
EditRun
Parameters:
x (tf.Tensor|TypedArray|Array) A floating point Tensor or TensorLike.
rate (number) A float in the range [0, 1). The probability that each element of x is discarded.
noiseShape (number[]) An array of numbers of type int32, representing the shape for randomly generated keep/drop flags. If the noiseShape has null value, it will be automatically replaced with the x's relative dimension size. Optional. Optional
seed (number|string) Used to create random seeds. Optional. Optional
Returns: tf.Tensor
Operations / Signal
tf.signal.frame (signal, frameLength, frameStep, padEnd?, padValue?) functionSource
Expands input into frames of frameLength. Slides a window size with frameStep.

tf.signal.frame([1, 2, 3], 2, 1).print();
EditRun
Parameters:
signal (tf.Tensor1D) The input tensor to be expanded
frameLength (number) Length of each frame
frameStep (number) The frame hop size in samples.
padEnd (boolean) Whether to pad the end of signal with padValue. Optional
padValue (number) A number to use where the input signal does not exist when padEnd is True. Optional
Returns: tf.Tensor
tf.signal.hammingWindow (windowLength) functionSource
Generate a hamming window.

See: https://en.wikipedia.org/wiki/Window_function#Hann_and_Hamming_windows

tf.signal.hammingWindow(10).print();
EditRun
Parameters:
windowLength (number)
Returns: tf.Tensor1D
tf.signal.hannWindow (windowLength) functionSource
Generate a Hann window.

See: https://en.wikipedia.org/wiki/Window_function#Hann_and_Hamming_windows

tf.signal.hannWindow(10).print();
EditRun
Parameters:
windowLength (number)
Returns: tf.Tensor1D
tf.signal.stft (signal, frameLength, frameStep, fftLength?, windowFn?) functionSource
Computes the Short-time Fourier Transform of signals See: https://en.wikipedia.org/wiki/Short-time_Fourier_transform

const input = tf.tensor1d([1, 1, 1, 1, 1])
tf.signal.stft(input, 3, 1).print();
EditRun
Parameters:
signal (tf.Tensor1D) 1-dimensional real value tensor.
frameLength (number) The window length of samples.
frameStep (number) The number of samples to step.
fftLength (number) The size of the FFT to apply. Optional
windowFn ((length: number) => tf.Tensor1D) A callable that takes a window length and returns 1-d tensor. Optional
Returns: tf.Tensor
Operations / Linear Algebra
tf.linalg.bandPart (a, numLower, numUpper) functionSource
Copy a tensor setting everything outside a central band in each innermost matrix to zero.

The band part is computed as follows: Assume input has k dimensions [I, J, K, ..., M, N], then the output is a tensor with the same shape where band[i, j, k, ..., m, n] = in_band(m, n) * input[i, j, k, ..., m, n]. The indicator function in_band(m, n) = (num_lower < 0 || (m-n) <= num_lower) && (num_upper < 0 || (n-m) <= num_upper)

const x = tf.tensor2d([[ 0,  1,  2, 3],
                        [-1,  0,  1, 2],
                        [-2, -1,  0, 1],
                        [-3, -2, -1, 0]]);
let y = tf.linalg.bandPart(x, 1, -1);
y.print(); // [[ 0,  1,  2, 3],
            //  [-1,  0,  1, 2],
            //  [ 0, -1,  0, 1],
            //  [ 0, 0 , -1, 0]]
let z = tf.linalg.bandPart(x, 2, 1);
z.print(); // [[ 0,  1,  0, 0],
            //  [-1,  0,  1, 0],
            //  [-2, -1,  0, 1],
            //  [ 0, -2, -1, 0]]
EditRun
Parameters:
a (tf.Tensor|TypedArray|Array)
numLower (number|tf.Scalar) Number of subdiagonals to keep. If negative, keep entire lower triangle.
numUpper (number|tf.Scalar) Number of subdiagonals to keep. If negative, keep entire upper triangle.
Returns: tf.Tensor
tf.linalg.gramSchmidt (xs) functionSource
Gram-Schmidt orthogonalization.

const x = tf.tensor2d([[1, 2], [3, 4]]);
let y = tf.linalg.gramSchmidt(x);
y.print();
console.log('Orthogonalized:');
y.dot(y.transpose()).print();  // should be nearly the identity matrix.
console.log('First row direction maintained:');
const data = await y.array();
console.log(data[0][1] / data[0][0]);  // should be nearly 2.
EditRun
Parameters:
xs (tf.Tensor1D[]|tf.Tensor2D) The vectors to be orthogonalized, in one of the two following formats:
An Array of tf.Tensor1D.
A tf.Tensor2D, i.e., a matrix, in which case the vectors are the rows of xs. In each case, all the vectors must have the same length and the length must be greater than or equal to the number of vectors.
Returns: tf.Tensor1D[]|tf.Tensor2D
tf.linalg.qr (x, fullMatrices?) functionSource
Compute QR decomposition of m-by-n matrix using Householder transformation.

Implementation based on [http://www.cs.cornell.edu/~bindel/class/cs6210-f09/lec18.pdf] (http://www.cs.cornell.edu/~bindel/class/cs6210-f09/lec18.pdf)

const a = tf.tensor2d([[1, 2], [3, 4]]);
let [q, r] = tf.linalg.qr(a);
console.log('Q');
q.print();
console.log('R');
r.print();
console.log('Orthogonalized');
q.dot(q.transpose()).print()  // should be nearly the identity matrix.
console.log('Reconstructed');
q.dot(r).print(); // should be nearly [[1, 2], [3, 4]];
EditRun
Parameters:
x (tf.Tensor) The tf.Tensor to be QR-decomposed. Must have rank >= 2. Suppose it has the shape [..., M, N].
fullMatrices (boolean) An optional boolean parameter. Defaults to false. If true, compute full-sized Q. If false (the default), compute only the leading N columns of Q and R. Optional
Returns: [tf.Tensor, tf.Tensor]
Operations / Sparse
tf.sparseFillEmptyRows (indices, values, denseShape, defaultValue) functionSource
The input SparseTensor is represented via the map of inputs {indices, values, denseShape}. The output SparseTensor has the same denseShape but with indices outputIndices and values outputValues. This op inserts a single entry for every row that doesn't have any values. The index is created as [row, 0, ..., 0] and the inserted value is defaultValue.

For example, suppose spInput has shape [5, 6] and non-empty values: [0, 1]: a [0, 3]: b [2, 0]: c [3, 1]: d

Rows 1 and 4 are empty, so the output will be of shape [5, 6] with values: [0, 1]: a [0, 3]: b [1, 0]: defaultValue [2, 0]: c [3, 1]: d [4, 0]: defaultValue

The output SparseTensor will be in row-major order and will have the same shape as the input.

This op also returns an indicator vector shaped [dense_shape[0]] such that emptyRowIndicator[i] = True iff row i was an empty row.

And a reverse index map vector shaped [indices.shape[0]] that is used during backpropagation, reverseIndexMap[i] = outi s.t. indices[i, j] == outputIndices[outi, j] for all j

const result = tf.sparse.sparseFillEmptyRows(
   [[0, 0], [1, 0], [1, 3], [1, 4], [3, 2], [3, 3]],
   [0, 10, 13, 14, 32, 33], [5, 6], -1);
console.log(result);
result['outputIndices'].print(); // [[0, 0], [1, 0], [1, 3], [1, 4],
                                  //  [2, 0], [3, 2], [3, 3], [4, 0]]
result['outputValues'].print(); // [0, 10, 13, 14,-1, 32, 33, -1]
result['emptyRowIndicator'].print(); // [false, false, true, false, true]
result['reverseIndexMap'].print(); // [0, 1, 2, 3, 5, 6]
EditRun
Parameters:
indices (tf.Tensor2D|TypedArray|Array) : 2-D. The indices of the sparse tensor.
values (tf.Tensor1D|TypedArray|Array) : 1-D. The values of the sparse tensor.
denseShape (tf.Tensor1D|TypedArray|Array) : 1-D. The shape of the sparse tensor.
defaultValue (tf.Scalar|ScalarLike) : 0-D. Default value to insert into location [row, 0, ..., 0] for rows missing from the input sparse tensor.
Returns: {[name: string]: tf.Tensor}
tf.sparseReshape (inputIndices, inputShape, newShape) functionSource
This operation has the same semantics as reshape on the represented dense tensor. The inputIndices are recomputed based on the requested newShape. If one component of newShape is the special value -1, the size of that dimension is computed so that the total dense size remains constant. At most one component of newShape can be -1. The number of dense elements implied by newShape must be the same as the number of dense elements originally implied by inputShape. Reshaping does not affect the order of values in the SparseTensor. If the input tensor has rank R_in and N non-empty values, and newShape has length R_out, then inputIndices has shape [N, R_in], inputShape has length R_in, outputIndices has shape [N, R_out], and outputShape has length R_out.

const result = tf.sparse.sparseReshape(
   [[0, 0, 0], [0, 0, 1], [0, 1, 0], [1, 0, 0], [1, 2, 3]],
   [2, 3, 6], [9, -1]);
console.log(result);
result['outputIndices'].print(); //[[0, 0], [0, 1], [1, 2], [4, 2], [8, 1]]
result['outputShape'].print(); // [9, 4]
EditRun
Parameters:
inputIndices (tf.Tensor2D|TypedArray|Array) : 2-D. N x R_in matrix with the indices of non-empty values in a SparseTensor.
inputShape (tf.Tensor1D|TypedArray|Array) : 1-D. R_in Tensor1D with the input SparseTensor's dense shape.
newShape (tf.Tensor1D|TypedArray|Array) : 1-D. R_out Tensor1D with the requested new dense shape.
Returns: {[name: string]: tf.Tensor}
tf.sparseSegmentMean (data, indices, segmentIds) functionSource
Computes the mean along sparse segments of a tensor.

const c = tf.tensor2d([[1,2,3,4], [-1,-2,-3,-4], [6,7,8,9]]);
// Select two rows, one segment.
const result1 = tf.sparse.sparseSegmentMean(c,
                                           tf.tensor1d([0, 1], 'int32'),
                                           tf.tensor1d([0, 0], 'int32'));
result1.print(); // [[0, 0, 0, 0]]

// Select two rows, two segments.
const result2 = tf.sparse.sparseSegmentMean(c,
                                             tf.tensor1d([0, 1], 'int32'),
                                             tf.tensor1d([0, 1], 'int32'));
result2.print(); // [[1, 2, 3, 4], [-1, -2, -3, -4]]

// Select all rows, two segments.
const result3 = tf.sparse.sparseSegmentMean(c,
                                             tf.tensor1d([0, 1, 2], 'int32'),
                                             tf.tensor1d([0, 1, 1], 'int32'));
result3.print(); // [[1.0, 2.0, 3.0, 4.0], [2.5, 2.5, 2.5, 2.5]]
EditRun
Parameters:
data (tf.Tensor|TypedArray|Array) : A Tensor of at least one dimension with data that will be assembled in the output.
indices (tf.Tensor1D|TypedArray|Array) : A 1-D Tensor with indices into data. Has same rank as segmentIds.
segmentIds (tf.Tensor1D|TypedArray|Array) : A 1-D Tensor with indices into the output Tensor. Values should be sorted and can be repeated.
Returns: tf.Tensor
tf.sparseSegmentSum (data, indices, segmentIds) functionSource
Computes the sum along sparse segments of a tensor.

const c = tf.tensor2d([[1,2,3,4], [-1,-2,-3,-4], [5,6,7,8]]);
// Select two rows, one segment.
const result1 = tf.sparse.sparseSegmentSum(c,
                                           tf.tensor1d([0, 1], 'int32'),
                                           tf.tensor1d([0, 0], 'int32'));
result1.print(); // [[0, 0, 0, 0]]

// Select two rows, two segments.
const result2 = tf.sparse.sparseSegmentSum(c,
                                           tf.tensor1d([0, 1], 'int32'),
                                           tf.tensor1d([0, 1], 'int32'));
result2.print(); // [[1, 2, 3, 4], [-1, -2, -3, -4]]

// Select all rows, two segments.
const result3 = tf.sparse.sparseSegmentSum(c,
                                           tf.tensor1d([0, 1, 2], 'int32'),
                                           tf.tensor1d([0, 0, 1], 'int32'));
result3.print(); // [[0, 0, 0, 0], [5, 6, 7, 8]]
EditRun
Parameters:
data (tf.Tensor|TypedArray|Array) : A Tensor of at least one dimension with data that will be assembled in the output.
indices (tf.Tensor1D|TypedArray|Array) : A 1-D Tensor with indices into data. Has same rank as segmentIds.
segmentIds (tf.Tensor1D|TypedArray|Array) : A 1-D Tensor with indices into the output Tensor. Values should be sorted and can be repeated.
Returns: tf.Tensor
Operations / String
tf.staticRegexReplace (input, pattern, rewrite, replaceGlobal?) functionSource
Replace the match of a pattern in input with rewrite.

const result = tf.string.staticRegexReplace(
     ['format       this   spacing      better'], ' +', ' ');
result.print(); // ['format this spacing better']
EditRun
Parameters:
input (tf.Tensor | TypedArray|Array) : A Tensor of type string. The text to be processed.
pattern (string) : A string. The regular expression to match the input.
rewrite (string) : A string. The rewrite to be applied to the matched expression.
replaceGlobal (boolean) : An optional bool. Defaults to True. If True, the replacement is global, otherwise the replacement is done only on the first match. Optional
Returns: tf.Tensor
tf.stringNGrams (data, dataSplits, separator, nGramWidths, leftPad, rightPad, padWidth, preserveShortSequences) functionSource
Creates ngrams from ragged string data.

This op accepts a ragged tensor with 1 ragged dimension containing only strings and outputs a ragged tensor with 1 ragged dimension containing ngrams of that string, joined along the innermost axis.

const result = tf.string.stringNGrams(
   ['a', 'b', 'c', 'd'], tf.tensor1d([0, 2, 4], 'int32'),
   '|', [1, 2], 'LP', 'RP', -1, false);
result['nGrams'].print(); // ['a', 'b', 'LP|a', 'a|b', 'b|RP',
                           //  'c', 'd', 'LP|c', 'c|d', 'd|RP']
result['nGramsSplits'].print(); // [0, 5, 10]
EditRun
Parameters:
data (tf.Tensor1D|TypedArray|Array) : The values tensor of the ragged string tensor to make ngrams out of. Must be a 1D string tensor.
dataSplits (tf.Tensor|TypedArray|Array) : The splits tensor of the ragged string tensor to make ngrams out of.
separator (string) : The string to append between elements of the token. Use "" for no separator.
nGramWidths (number[]) : The sizes of the ngrams to create.
leftPad (string) : The string to use to pad the left side of the ngram sequence. Only used if pad_width !== 0.
rightPad (string) : The string to use to pad the right side of the ngram sequence. Only used if pad_width !== 0.
padWidth (number) : The number of padding elements to add to each side of each sequence. Note that padding will never be greater than nGramWidths-1 regardless of this value. If padWidth=-1, then add max(nGramWidths)-1 elements.
preserveShortSequences (boolean) : If true, then ensure that at least one ngram is generated for each input sequence. In particular, if an input sequence is shorter than min(ngramWidth) + 2*padWidth, then generate a single ngram containing the entire sequence. If false, then no ngrams are generated for these short input sequences.
Returns: {[name: string]: tf.Tensor}
tf.stringSplit (input, delimiter, skipEmpty?) functionSource
Split elements of input based on delimiter into a SparseTensor .

Let N be the size of source (typically N will be the batch size). Split each element of input based on delimiter and return a SparseTensor containing the splitted tokens. Empty tokens are ignored if skipEmpty is set to True.

delimiter can be empty, or a string of split characters. If delimiter is an empty string, each element of input is split into individual character strings. Otherwise every character of delimiter is a potential split point.

const result = tf.string.stringSplit(['hello world',  'a b c'], ' ');
result['indices'].print(); // [[0, 0], [0, 1], [1, 0], [1, 1], [1, 2]]
result['values'].print(); // ['hello', 'world', 'a', 'b', 'c']
result['shape'].print(); // [2, 3]
EditRun
Parameters:
input (tf.Tensor1D|TypedArray|Array) : 1-D. Strings to split.
delimiter (tf.Scalar|ScalarLike) : 0-D. Delimiter characters, or empty string.
skipEmpty (boolean) : Optional. If true, skip the empty strings from the result. Defaults to true. Optional
Returns: {[name: string]: tf.Tensor}
tf.stringToHashBucketFast (input, numBuckets) functionSource
Converts each string in the input Tensor to its hash mod by a number of buckets.

The hash function is deterministic on the content of the string within the process and will never change. However, it is not suitable for cryptography. This function may be used when CPU time is scarce and inputs are trusted or unimportant. There is a risk of adversaries constructing inputs that all hash to the same bucket.

const result = tf.string.stringToHashBucketFast(
   ['Hello', 'TensorFlow', '2.x'], 3);
result.print(); // [0, 2, 2]
EditRun
Parameters:
input (tf.Tensor|TypedArray|Array) : The strings to assign a hash bucket.
numBuckets (number) : The number of buckets.
Returns: tf.Tensor
Training
We also provide an API to do perform training, and compute gradients. We compute gradients eagerly, users provide a function that is a combination of operations and we automatically differentiate that function's output with respect to its inputs.

For those familiar with TensorFlow, the API we expose exactly mirrors the TensorFlow Eager API.

Training / Gradients
tf.grad (f) functionSource
Provided f(x), returns another function g(x, dy?), which gives the gradient of f(x) with respect to x.

If dy is provided, the gradient of f(x).mul(dy).sum() with respect to x is computed instead. f(x) must take a single tensor x and return a single tensor y. If f() takes multiple inputs, use tf.grads() instead.

// f(x) = x ^ 2
const f = x => x.square();
// f'(x) = 2x
const g = tf.grad(f);

const x = tf.tensor1d([2, 3]);
g(x).print();
EditRun
// f(x) = x ^ 3
const f = x => x.pow(tf.scalar(3, 'int32'));
// f'(x) = 3x ^ 2
const g = tf.grad(f);
// f''(x) = 6x
const gg = tf.grad(g);

const x = tf.tensor1d([2, 3]);
gg(x).print();
EditRun
Parameters:
f ((x: tf.Tensor) => tf.Tensor) The function f(x), to compute gradient for.
Returns: ( x: TypedArray|Array|tf.Tensor, dy?: TypedArray|Array|tf.Tensor) => tf.Tensor
tf.grads (f) functionSource
Provided f(x1, x2,...), returns another function g([x1, x2,...], dy?), which gives an array of gradients of f() with respect to each input [x1,x2,...].

If dy is passed when calling g(), the gradient of f(x1,...).mul(dy).sum() with respect to each input is computed instead. The provided f must take one or more tensors and return a single tensor y. If f() takes a single input, we recommend using tf.grad() instead.

// f(a, b) = a * b
const f = (a, b) => a.mul(b);
// df / da = b, df / db = a
const g = tf.grads(f);

const a = tf.tensor1d([2, 3]);
const b = tf.tensor1d([-2, -3]);
const [da, db] = g([a, b]);
console.log('da');
da.print();
console.log('db');
db.print();
EditRun
Parameters:
f ((...args: tf.Tensor[]) => tf.Tensor) The function f(x1, x2,...) to compute gradients for.
Returns: ( args: Array, dy?: tf.Tensor|TypedArray|Array) => tf.Tensor[]
tf.customGrad (f) functionSource
Overrides the gradient computation of a function f.

Takes a function f(...inputs, save) => {value: Tensor, gradFunc: (dy, saved) => Tensor[]} and returns another function g(...inputs) which takes the same inputs as f. When called, g returns f().value. In backward mode, custom gradients with respect to each input of f are computed using f().gradFunc.

The save function passed to f should be used for saving tensors needed in the gradient. And the saved passed to the gradFunc is a NamedTensorMap, which contains those saved tensors.

const customOp = tf.customGrad((x, save) => {
   // Save x to make sure it's available later for the gradient.
   save([x]);
   // Override gradient of our custom x ^ 2 op to be dy * abs(x);
   return {
     value: x.square(),
     // Note `saved.x` which points to the `x` we saved earlier.
     gradFunc: (dy, saved) => [dy.mul(saved[0].abs())]
   };
});

const x = tf.tensor1d([-1, -2, 3]);
const dx = tf.grad(x => customOp(x));

console.log(`f(x):`);
customOp(x).print();
console.log(`f'(x):`);
dx(x).print();
EditRun
Parameters:
f ((a: tf.Tensor, b: tf.Tensor,..., [tf.GraphModel.tf.LayersModel.save()()](#tf.GraphModel.tf.LayersModel.save())?: Function) => { value: tf.Tensor, gradFunc: (dy: tf.Tensor, saved?: NamedTensorMap) => tf.Tensor | tf.Tensor[] }) The function to evaluate in forward mode, which should return {value: Tensor, gradFunc: (dy, saved) => Tensor[]}, where gradFunc returns the custom gradients of f with respect to its inputs.
Returns: (...args: tf.Tensor[]) => tf.Tensor
tf.valueAndGrad (f) functionSource
Like tf.grad(), but also returns the value of f(). Useful when f() returns a metric you want to show.

The result is a rich object with the following properties:

grad: The gradient of f(x) w.r.t. x (result of tf.grad()).
value: The value returned by f(x).
// f(x) = x ^ 2
const f = x => x.square();
// f'(x) = 2x
const g = tf.valueAndGrad(f);

const x = tf.tensor1d([2, 3]);
const {value, grad} = g(x);

console.log('value');
value.print();
console.log('grad');
grad.print();
EditRun
Parameters:
f ((x: tf.Tensor) => tf.Tensor)
Returns: ( x: tf.Tensor, dy?: tf.Tensor) => { value: tf.Tensor; grad: tf.Tensor; }
tf.valueAndGrads (f) functionSource
Like tf.grads(), but returns also the value of f(). Useful when f() returns a metric you want to show.

The result is a rich object with the following properties:

grads: The gradients of f() w.r.t. each input (result of tf.grads()).
value: The value returned by f(x).
// f(a, b) = a * b
const f = (a, b) => a.mul(b);
// df/da = b, df/db = a
const g = tf.valueAndGrads(f);

const a = tf.tensor1d([2, 3]);
const b = tf.tensor1d([-2, -3]);
const {value, grads} = g([a, b]);

const [da, db] = grads;

console.log('value');
value.print();

console.log('da');
da.print();
console.log('db');
db.print();
EditRun
Parameters:
f ((...args: tf.Tensor[]) => tf.Tensor)
Returns: ( args: tf.Tensor[], dy?: tf.Tensor) => { grads: tf.Tensor[]; value: tf.Tensor; }
tf.variableGrads (f, varList?) functionSource
Computes and returns the gradient of f(x) with respect to the list of trainable variables provided by varList. If no list is provided, it defaults to all trainable variables.

const a = tf.variable(tf.tensor1d([3, 4]));
const b = tf.variable(tf.tensor1d([5, 6]));
const x = tf.tensor1d([1, 2]);

// f(a, b) = a * x ^ 2 + b * x
const f = () => a.mul(x.square()).add(b.mul(x)).sum();
// df/da = x ^ 2, df/db = x
const {value, grads} = tf.variableGrads(f);

Object.keys(grads).forEach(varName => grads[varName].print());
EditRun
Parameters:
f (() => tf.Scalar) The function to execute. f() should return a scalar.
varList (tf.Variable[]) The list of variables to compute the gradients with respect to. Defaults to all trainable variables. Optional
Returns: {value: tf.Scalar, grads: {[name: string]: tf.Tensor}}
Training / Optimizers
tf.train.sgd (learningRate) functionSource
Constructs a tf.SGDOptimizer that uses stochastic gradient descent.

// Fit a quadratic function by learning the coefficients a, b, c.
const xs = tf.tensor1d([0, 1, 2, 3]);
const ys = tf.tensor1d([1.1, 5.9, 16.8, 33.9]);

const a = tf.scalar(Math.random()).variable();
const b = tf.scalar(Math.random()).variable();
const c = tf.scalar(Math.random()).variable();

// y = a * x^2 + b * x + c.
const f = x => a.mul(x.square()).add(b.mul(x)).add(c);
const loss = (pred, label) => pred.sub(label).square().mean();

const learningRate = 0.01;
const optimizer = tf.train.sgd(learningRate);

// Train the model.
for (let i = 0; i < 10; i++) {
   optimizer.minimize(() => loss(f(xs), ys));
}

// Make predictions.
console.log(
     `a: ${a.dataSync()}, b: ${b.dataSync()}, c: ${c.dataSync()}`);
const preds = f(xs).dataSync();
preds.forEach((pred, i) => {
   console.log(`x: ${i}, pred: ${pred}`);
});
EditRun
Parameters:
learningRate (number) The learning rate to use for the SGD algorithm.
Returns: tf.SGDOptimizer
tf.train.momentum (learningRate, momentum, useNesterov?) functionSource
Constructs a tf.MomentumOptimizer that uses momentum gradient descent.

See http://proceedings.mlr.press/v28/sutskever13.pdf

Parameters:
learningRate (number) The learning rate to use for the Momentum gradient descent algorithm.
momentum (number) The momentum to use for the momentum gradient descent algorithm.
useNesterov (boolean) Optional
Returns: tf.MomentumOptimizer
tf.train.adagrad (learningRate, initialAccumulatorValue?) functionSource
Constructs a tf.AdagradOptimizer that uses the Adagrad algorithm. See http://www.jmlr.org/papers/volume12/duchi11a/duchi11a.pdf or http://ruder.io/optimizing-gradient-descent/index.html#adagrad

Parameters:
learningRate (number) The learning rate to use for the Adagrad gradient descent algorithm.
initialAccumulatorValue (number) Starting value for the accumulators, must be positive. Optional
Returns: tf.AdagradOptimizer
tf.train.adadelta (learningRate?, rho?, epsilon?) functionSource
Constructs a tf.AdadeltaOptimizer that uses the Adadelta algorithm. See https://arxiv.org/abs/1212.5701

Parameters:
learningRate (number) The learning rate to use for the Adadelta gradient descent algorithm. Optional
rho (number) The learning rate decay over each update. Optional
epsilon (number) A constant epsilon used to better condition the grad update. Optional
Returns: tf.AdadeltaOptimizer
tf.train.adam (learningRate?, beta1?, beta2?, epsilon?) functionSource
Constructs a tf.AdamOptimizer that uses the Adam algorithm. See https://arxiv.org/abs/1412.6980

Parameters:
learningRate (number) The learning rate to use for the Adam gradient descent algorithm. Optional
beta1 (number) The exponential decay rate for the 1st moment estimates. Optional
beta2 (number) The exponential decay rate for the 2nd moment estimates. Optional
epsilon (number) A small constant for numerical stability. Optional
Returns: AdamOptimizer
tf.train.adamax (learningRate?, beta1?, beta2?, epsilon?, decay?) functionSource
Constructs a tf.AdamaxOptimizer that uses the Adamax algorithm. See https://arxiv.org/abs/1412.6980

Parameters:
learningRate (number) The learning rate to use for the Adamax gradient descent algorithm. Optional
beta1 (number) The exponential decay rate for the 1st moment estimates. Optional
beta2 (number) The exponential decay rate for the 2nd moment estimates. Optional
epsilon (number) A small constant for numerical stability. Optional
decay (number) The learning rate decay over each update. Optional
Returns: AdamaxOptimizer
tf.train.rmsprop (learningRate, decay?, momentum?, epsilon?, centered?) functionSource
Constructs a tf.RMSPropOptimizer that uses RMSProp gradient descent. This implementation uses plain momentum and is not centered version of RMSProp.

See http://www.cs.toronto.edu/~tijmen/csc321/slides/lecture_slides_lec6.pdf

Parameters:
learningRate (number) The learning rate to use for the RMSProp gradient descent algorithm.
decay (number) The discounting factor for the history/coming gradient. Optional
momentum (number) The momentum to use for the RMSProp gradient descent algorithm. Optional
epsilon (number) Small value to avoid zero denominator. Optional
centered (boolean) If true, gradients are normalized by the estimated variance of the gradient. Optional
Returns: tf.RMSPropOptimizer
Training / Losses
tf.losses.absoluteDifference (labels, predictions, weights?, reduction?) functionSource
Computes the absolute difference loss between two tensors.

Parameters:
labels (tf.Tensor|TypedArray|Array) The ground truth output tensor, same dimensions as 'predictions'.
predictions (tf.Tensor|TypedArray|Array) The predicted outputs.
weights (tf.Tensor|TypedArray|Array) Tensor whose rank is either 0, or the same rank as labels, and must be broadcastable to labels (i.e., all dimensions must be either 1, or the same as the corresponding losses dimension). Optional
reduction (Reduction) Type of reduction to apply to loss. Should be of type Reduction Optional
Returns: tf.Tensor
tf.losses.computeWeightedLoss (losses, weights?, reduction?) functionSource
Computes the weighted loss between two tensors.

Parameters:
losses (tf.Tensor|TypedArray|Array) Tensor of shape [batch_size, d1, ..., dN].
weights (tf.Tensor|TypedArray|Array) Tensor whose rank is either 0, or the same rank as losses, and must be broadcastable to losses (i.e., all dimensions must be either 1, or the same as the corresponding losses dimension). Optional
reduction (Reduction) Optional
Returns: tf.Tensor
tf.losses.cosineDistance (labels, predictions, axis, weights?, reduction?) functionSource
Computes the cosine distance loss between two tensors.

Parameters:
labels (tf.Tensor|TypedArray|Array) The ground truth output tensor, same dimensions as 'predictions'.
predictions (tf.Tensor|TypedArray|Array) The predicted outputs.
axis (number) The dimension along which the cosine distance is computed.
weights (tf.Tensor|TypedArray|Array) Tensor whose rank is either 0, or the same rank as labels, and must be broadcastable to labels (i.e., all dimensions must be either 1, or the same as the corresponding losses dimension). Optional
reduction (Reduction) Type of reduction to apply to loss. Should be of type Reduction Optional
Returns: tf.Tensor
tf.losses.hingeLoss (labels, predictions, weights?, reduction?) functionSource
Computes the Hinge loss between two tensors.

Parameters:
labels (tf.Tensor|TypedArray|Array) The ground truth output tensor, same dimensions as 'predictions'.
predictions (tf.Tensor|TypedArray|Array) The predicted outputs.
weights (tf.Tensor|TypedArray|Array) Tensor whose rank is either 0, or the same rank as labels, and must be broadcastable to labels (i.e., all dimensions must be either 1, or the same as the corresponding losses dimension). Optional
reduction (Reduction) Type of reduction to apply to loss. Should be of type Reduction Optional
Returns: tf.Tensor
tf.losses.huberLoss (labels, predictions, weights?, delta?, reduction?) functionSource
Computes the Huber loss between two tensors.

Parameters:
labels (tf.Tensor|TypedArray|Array) The ground truth output tensor, same dimensions as 'predictions'.
predictions (tf.Tensor|TypedArray|Array) The predicted outputs.
weights (tf.Tensor|TypedArray|Array) Tensor whose rank is either 0, or the same rank as labels, and must be broadcastable to labels (i.e., all dimensions must be either 1, or the same as the corresponding losses dimension). Optional
delta (number) Point where Huber loss changes from quadratic to linear. Optional
reduction (Reduction) Type of reduction to apply to loss. Should be of type Reduction. Optional
Returns: tf.Tensor
tf.losses.logLoss (labels, predictions, weights?, epsilon?, reduction?) functionSource
Computes the log loss between two tensors.

Parameters:
labels (tf.Tensor|TypedArray|Array) The ground truth output tensor, same dimensions as 'predictions'.
predictions (tf.Tensor|TypedArray|Array) The predicted outputs.
weights (tf.Tensor|TypedArray|Array) Tensor whose rank is either 0, or the same rank as labels, and must be broadcastable to labels (i.e., all dimensions must be either 1, or the same as the corresponding losses dimension). Optional
epsilon (number) A small increment to avoid taking log of zero Optional
reduction (Reduction) Type of reduction to apply to loss. Should be of type Reduction Optional
Returns: tf.Tensor
tf.losses.meanSquaredError (labels, predictions, weights?, reduction?) functionSource
Computes the mean squared error between two tensors.

Parameters:
labels (tf.Tensor|TypedArray|Array) The ground truth output tensor, same dimensions as 'predictions'.
predictions (tf.Tensor|TypedArray|Array) The predicted outputs.
weights (tf.Tensor|TypedArray|Array) Tensor whose rank is either 0, or the same rank as labels, and must be broadcastable to labels (i.e., all dimensions must be either 1, or the same as the corresponding losses dimension). Optional
reduction (Reduction) Type of reduction to apply to loss. Should be of type Reduction Optional
Returns: tf.Tensor
tf.losses.sigmoidCrossEntropy (multiClassLabels, logits, weights?, labelSmoothing?, reduction?) functionSource
Computes the sigmoid cross entropy loss between two tensors.

If labelSmoothing is nonzero, smooth the labels towards 1/2:

newMulticlassLabels = multiclassLabels * (1 - labelSmoothing) + 0.5 * labelSmoothing

Parameters:
multiClassLabels (tf.Tensor|TypedArray|Array) The ground truth output tensor of shape [batch_size, num_classes], same dimensions as 'predictions'.
logits (tf.Tensor|TypedArray|Array) The predicted outputs.
weights (tf.Tensor|TypedArray|Array) Tensor whose rank is either 0, or the same rank as labels, and must be broadcastable to labels (i.e., all dimensions must be either 1, or the same as the corresponding losses dimension). Optional
labelSmoothing (number) If greater than 0, then smooth the labels. Optional
reduction (Reduction) Type of reduction to apply to loss. Should be of type Reduction Optional
Returns: tf.Tensor
tf.losses.softmaxCrossEntropy (onehotLabels, logits, weights?, labelSmoothing?, reduction?) functionSource
Computes the softmax cross entropy loss between two tensors.

If labelSmoothing is nonzero, smooth the labels towards 1/2:

newOnehotLabels = onehotLabels * (1 - labelSmoothing) + labelSmoothing / numClasses

Parameters:
onehotLabels (tf.Tensor|TypedArray|Array) One hot encoded labels [batch_size, num_classes], same dimensions as 'predictions'.
logits (tf.Tensor|TypedArray|Array) The predicted outputs.
weights (tf.Tensor|TypedArray|Array) Tensor whose rank is either 0, or 1, and must be broadcastable to loss of shape [batch_size] Optional
labelSmoothing (number) If greater than 0, then smooth the labels. Optional
reduction (Reduction) Type of reduction to apply to loss. Should be of type Reduction Optional
Returns: tf.Tensor
Training / Classes
tf.train.Optimizer extends Serializable classSource
minimize (f, returnCost?, varList?) methodSource
Executes f() and minimizes the scalar output of f() by computing gradients of y with respect to the list of trainable variables provided by varList. If no list is provided, it defaults to all trainable variables.

Parameters:
f (() => tf.Scalar) The function to execute and whose output to minimize.
returnCost (boolean) Whether to return the scalar cost value produced by executing f(). Optional
varList (tf.Variable[]) An optional list of variables to update. If specified, only the trainable variables in varList will be updated by minimize. Defaults to all trainable variables. Optional
Returns: tf.Scalar |null
computeGradients (f, varList?) methodSource
Executes f() and computes the gradient of the scalar output of f() with respect to the list of trainable variables provided by varList. If no list is provided, it defaults to all trainable variables.

Parameters:
f (() => tf.Scalar) The function to execute and whose output to use for computing gradients with respect to variables.
varList (tf.Variable[]) An optional list of variables to compute gradients with respect to. If specified, only the trainable variables in varList will have gradients computed with respect to. Defaults to all trainable variables. Optional
Returns: {value: tf.Scalar, grads: {[name: string]: tf.Tensor}}
applyGradients (variableGradients) methodSource
Updates variables by using the computed gradients.

Parameters:
variableGradients ({[name: string]: tf.Tensor}| NamedTensor[]) A mapping of variable name to its gradient value.
Returns: void
Performance
Performance / Memory
tf.tidy (nameOrFn, fn?) functionSource
Executes the provided function fn and after it is executed, cleans up all intermediate tensors allocated by fn except those returned by fn. fn must not return a Promise (async functions not allowed). The returned result can be a complex object.

Using this method helps avoid memory leaks. In general, wrap calls to operations in tf.tidy() for automatic memory cleanup.

NOTE: Variables do not get cleaned up when inside a tidy(). If you want to dispose variables, please use tf.disposeVariables() or call dispose() directly on variables.

// y = 2 ^ 2 + 1
const y = tf.tidy(() => {
   // a, b, and one will be cleaned up when the tidy ends.
   const one = tf.scalar(1);
   const a = tf.scalar(2);
   const b = a.square();

   console.log('numTensors (in tidy): ' + tf.memory().numTensors);

   // The value returned inside the tidy function will return
   // through the tidy, in this case to the variable y.
   return b.add(one);
});

console.log('numTensors (outside tidy): ' + tf.memory().numTensors);
y.print();
EditRun
Parameters:
nameOrFn (string|Function) The name of the closure, or the function to execute. If a name is provided, the 2nd argument should be the function. If debug mode is on, the timing and the memory usage of the function will be tracked and displayed on the console using the provided name.
fn (Function) The function to execute. Optional
Returns: void|number|string|TypedArray|tf.Tensor|tf.Tensor[]|{[key: string]:tf.Tensor|number|string}
tf.dispose (container) functionSource
Disposes any tf.Tensors found within the provided object.

Parameters:
container (void|number|string|TypedArray|tf.Tensor|tf.Tensor[]|{[key: string]:tf.Tensor|number|string}) an object that may be a tf.Tensor or may directly contain tf.Tensors, such as a Tensor[] or {key: Tensor, ...}. If the object is not a tf.Tensor or does not contain Tensors, nothing happens. In general it is safe to pass any object here, except that Promises are not supported.
Returns: void
tf.keep (result) functionSource
Keeps a tf.Tensor generated inside a tf.tidy() from being disposed automatically.

let b;
const y = tf.tidy(() => {
   const one = tf.scalar(1);
   const a = tf.scalar(2);

   // b will not be cleaned up by the tidy. a and one will be cleaned up
   // when the tidy ends.
   b = tf.keep(a.square());

   console.log('numTensors (in tidy): ' + tf.memory().numTensors);

   // The value returned inside the tidy function will return
   // through the tidy, in this case to the variable y.
   return b.add(one);
});

console.log('numTensors (outside tidy): ' + tf.memory().numTensors);
console.log('y:');
y.print();
console.log('b:');
b.print();
EditRun
Parameters:
result (tf.Tensor) The tensor to keep from being disposed.
Returns: tf.Tensor
tf.memory () functionSource
Returns memory info at the current time in the program. The result is an object with the following properties:

numBytes: Number of bytes allocated (undisposed) at this time.
numTensors: Number of unique tensors allocated.
numDataBuffers: Number of unique data buffers allocated (undisposed) at this time, which is  the number of tensors (e.g. a.reshape(newShape) makes a new Tensor that shares the same data buffer with a).
unreliable: True if the memory usage is unreliable. See reasons when unreliable is true.
reasons: string[], reasons why the memory is unreliable, present if unreliable is true.
WebGL Properties:

numBytesInGPU: Number of bytes allocated (undisposed) in the GPU only at this time.
Returns: MemoryInfo
Performance / Timing
tf.time (f) functionSource
Executes f() and returns a promise that resolves with timing information.

The result is an object with the following properties:

wallMs: Wall execution time.
kernelMs: Kernel execution time, ignoring data transfer. If using the WebGL backend and the query timer extension is not available, this will return an error object.
On WebGL The following additional properties exist:
uploadWaitMs: CPU blocking time on texture uploads.
downloadWaitMs: CPU blocking time on texture downloads (readPixels).
const x = tf.randomNormal([20, 20]);
const time = await tf.time(() => x.matMul(x));

console.log(`kernelMs: ${time.kernelMs}, wallTimeMs: ${time.wallMs}`);
EditRun
Parameters:
f (() => void) The function to execute and time.
Returns: Promise<TimingInfo>
tf.nextFrame () functionSource
Returns a promise that resolves when a requestAnimationFrame has completed.

On Node.js this uses setImmediate instead of requestAnimationFrame.

This is simply a sugar method so that users can do the following: await tf.nextFrame();

Returns: Promise<void>
Performance / Profile
tf.profile (f) functionSource
Executes the provided function f() and returns a promise that resolves with information about the function's memory use:

newBytes: the number of new bytes allocated
newTensors: the number of new tensors created
peakBytes: the peak number of bytes allocated
kernels: an array of objects for each kernel involved that reports their input and output shapes, number of bytes used, and number of new tensors created.
kernelNames: an array of unique strings with just the names of the kernels in the kernels array.
const profile = await tf.profile(() => {
   const x = tf.tensor1d([1, 2, 3]);
   let x2 = x.square();
   x2.dispose();
   x2 = x.square();
   x2.dispose();
   return x;
});

console.log(`newBytes: ${profile.newBytes}`);
console.log(`newTensors: ${profile.newTensors}`);
console.log(`byte usage over all kernels: ${profile.kernels.map(k =>
k.totalBytesSnapshot)}`);
EditRun
Parameters:
f (() => (void|number|string|TypedArray|tf.Tensor|tf.Tensor[]|{[key: string]:tf.Tensor|number|string} | Promise<void|number|string|TypedArray|tf.Tensor|tf.Tensor[]|{[key: string]:tf.Tensor|number|string}>))
Returns: Promise<ProfileInfo>
Environment
TensorFlow.js can run mathematical operations on different backends. Currently, we support WebGL and JavaScript CPU. By default, we choose the 'best' backend available, but allow users to customize their backend.

Environment /
tf.Environment classSource
The environment contains evaluated flags as well as the registered platform. This is always used as a global singleton and can be retrieved with tf.env().

tf.disposeVariables () functionSource
Dispose all variables kept in backend engine.

Returns: void
tf.enableDebugMode () functionSource
Enables debug mode which will log information about all executed kernels: the elapsed time of the kernel execution, as well as the rank, shape, and size of the output tensor.

Debug mode will significantly slow down your application as it will download the result of every operation to the CPU. This should not be used in production. Debug mode does not affect the timing information of the kernel execution as we do not measure download time in the kernel execution time.

See also: tf.profile(), tf.memory().

Returns: void
tf.enableProdMode () functionSource
Enables production mode which disables correctness checks in favor of performance.

Returns: void
tf.engine () functionSource
It returns the global engine that keeps track of all tensors and backends.

Returns: Engine
tf.env () functionSource
Returns the current environment (a global singleton).

The environment object contains the evaluated feature values as well as the active platform.

Returns: tf.Environment
Constraints
Constraints are added to attributes of a Layer (such as weights, kernels, or biases) at construction time to clamp, or otherwise enforce an allowed range, of values for different components of the Layer.

Constraints / Classes
tf.constraints.Constraint extends serialization.Serializable classSource
Base class for functions that impose constraints on weight values

Constraints /
tf.constraints.maxNorm (args) functionSource
MaxNorm weight constraint.

Constrains the weights incident to each hidden unit to have a norm less than or equal to a desired value.

References - Dropout: A Simple Way to Prevent Neural Networks from Overfitting Srivastava, Hinton, et al. 2014

Parameters:
args (Object)
maxValue (number) Maximum norm for incoming weights
axis (number) Axis along which to calculate norms.
For instance, in a Dense layer the weight matrix has shape [inputDim, outputDim], set axis to 0 to constrain each weight vector of length [inputDim,]. In a Conv2D layer with dataFormat="channels_last", the weight tensor has shape [rows, cols, inputDepth, outputDepth], set axis to [0, 1, 2] to constrain the weights of each filter tensor of size [rows, cols, inputDepth].

Returns: tf.constraints.Constraint
tf.constraints.minMaxNorm (config) functionSource
Parameters:
config (Object)
minValue (number) Minimum norm for incoming weights
maxValue (number) Maximum norm for incoming weights
axis (number) Axis along which to calculate norms. For instance, in a Dense layer the weight matrix has shape [inputDim, outputDim], set axis to 0 to constrain each weight vector of length [inputDim,]. In a Conv2D layer with dataFormat="channels_last", the weight tensor has shape [rows, cols, inputDepth, outputDepth], set axis to [0, 1, 2] to constrain the weights of each filter tensor of size [rows, cols, inputDepth].
rate (number) Rate for enforcing the constraint: weights will be rescaled to yield: (1 - rate) * norm + rate * norm.clip(minValue, maxValue). Effectively, this means that rate=1.0 stands for strict enforcement of the constraint, while rate<1.0 means that weights will be rescaled at each step to slowly move towards a value inside the desired interval.
Returns: tf.constraints.Constraint
tf.constraints.nonNeg () functionSource
Constrains the weight to be non-negative.

Returns: tf.constraints.Constraint
tf.constraints.unitNorm (args) functionSource
Constrains the weights incident to each hidden unit to have unit norm.

Parameters:
args (Object)
axis (number) Axis along which to calculate norms.
For instance, in a Dense layer the weight matrix has shape [inputDim, outputDim], set axis to 0 to constrain each weight vector of length [inputDim,]. In a Conv2D layer with dataFormat="channels_last", the weight tensor has shape [rows, cols, inputDepth, outputDepth], set axis to [0, 1, 2] to constrain the weights of each filter tensor of size [rows, cols, inputDepth].

Returns: tf.constraints.Constraint
Initializers
Initializers are used in Layers to establish the starting the values of weights, biases, kernels, etc.

Initializers / Classes
tf.initializers.Initializer extends serialization.Serializable classSource
Initializer base class.

Initializers /
tf.initializers.constant (args) functionSource
Initializer that generates values initialized to some constant.

Parameters:
args (Object)
value (number) The value for each element in the variable.
Returns: tf.initializers.Initializer
tf.initializers.glorotNormal (args) functionSource
Glorot normal initializer, also called Xavier normal initializer. It draws samples from a truncated normal distribution centered on 0 with stddev = sqrt(2 / (fan_in + fan_out)) where fan_in is the number of input units in the weight tensor and fan_out is the number of output units in the weight tensor.

Reference: Glorot & Bengio, AISTATS 2010 http://jmlr.org/proceedings/papers/v9/glorot10a/glorot10a.pdf

Parameters:
args (Object)
seed (number) Random number generator seed.
Returns: tf.initializers.Initializer
tf.initializers.glorotUniform (args) functionSource
Glorot uniform initializer, also called Xavier uniform initializer. It draws samples from a uniform distribution within [-limit, limit] where limit is sqrt(6 / (fan_in + fan_out)) where fan_in is the number of input units in the weight tensor and fan_out is the number of output units in the weight tensor

Reference: Glorot & Bengio, AISTATS 2010 http://jmlr.org/proceedings/papers/v9/glorot10a/glorot10a.pdf.

Parameters:
args (Object)
seed (number) Random number generator seed.
Returns: tf.initializers.Initializer
tf.initializers.heNormal (args) functionSource
He normal initializer.

It draws samples from a truncated normal distribution centered on 0 with stddev = sqrt(2 / fanIn) where fanIn is the number of input units in the weight tensor.

Reference: He et al., http://arxiv.org/abs/1502.01852

Parameters:
args (Object)
seed (number) Random number generator seed.
Returns: tf.initializers.Initializer
tf.initializers.heUniform (args) functionSource
He uniform initializer.

It draws samples from a uniform distribution within [-limit, limit] where limit is sqrt(6 / fan_in) where fanIn is the number of input units in the weight tensor.

Reference: He et al., http://arxiv.org/abs/1502.01852

Parameters:
args (Object)
seed (number) Random number generator seed.
Returns: tf.initializers.Initializer
tf.initializers.identity (args) functionSource
Initializer that generates the identity matrix. Only use for square 2D matrices.

Parameters:
args (Object)
gain (number) Multiplicative factor to apply to the identity matrix.
Returns: tf.initializers.Initializer
tf.initializers.leCunNormal (args) functionSource
LeCun normal initializer.

It draws samples from a truncated normal distribution centered on 0 with stddev = sqrt(1 / fanIn) where fanIn is the number of input units in the weight tensor.

References: Self-Normalizing Neural Networks Efficient Backprop

Parameters:
args (Object)
seed (number) Random number generator seed.
Returns: tf.initializers.Initializer
tf.initializers.leCunUniform (args) functionSource
LeCun uniform initializer.

It draws samples from a uniform distribution in the interval [-limit, limit] with limit = sqrt(3 / fanIn), where fanIn is the number of input units in the weight tensor.

Parameters:
args (Object)
seed (number) Random number generator seed.
Returns: tf.initializers.Initializer
tf.initializers.ones () functionSource
Initializer that generates tensors initialized to 1.

Returns: tf.initializers.Initializer
tf.initializers.orthogonal (args) functionSource
Initializer that generates a random orthogonal matrix.

Reference: Saxe et al., http://arxiv.org/abs/1312.6120

Parameters:
args (Object)
gain (number) Multiplicative factor to apply to the orthogonal matrix. Defaults to 1.
seed (number) Random number generator seed.
Returns: tf.initializers.Initializer
tf.initializers.randomNormal (args) functionSource
Initializer that generates random values initialized to a normal distribution.

Parameters:
args (Object)
mean (number) Mean of the random values to generate.
stddev (number) Standard deviation of the random values to generate.
seed (number) Used to seed the random generator.
Returns: tf.initializers.Initializer
tf.initializers.randomUniform (args) functionSource
Initializer that generates random values initialized to a uniform distribution.

Values will be distributed uniformly between the configured minval and maxval.

Parameters:
args (Object)
minval (number) Lower bound of the range of random values to generate.
maxval (number) Upper bound of the range of random values to generate.
seed (number) Used to seed the random generator.
Returns: tf.initializers.Initializer
tf.initializers.truncatedNormal (args) functionSource
Initializer that generates random values initialized to a truncated normal distribution.

These values are similar to values from a RandomNormal except that values more than two standard deviations from the mean are discarded and re-drawn. This is the recommended initializer for neural network weights and filters.

Parameters:
args (Object)
mean (number) Mean of the random values to generate.
stddev (number) Standard deviation of the random values to generate.
seed (number) Used to seed the random generator.
Returns: tf.initializers.Initializer
tf.initializers.varianceScaling (config) functionSource
Initializer capable of adapting its scale to the shape of weights. With distribution=NORMAL, samples are drawn from a truncated normal distribution centered on zero, with stddev = sqrt(scale / n) where n is:

number of input units in the weight tensor, if mode = FAN_IN.
number of output units, if mode = FAN_OUT.
average of the numbers of input and output units, if mode = FAN_AVG. With distribution=UNIFORM, samples are drawn from a uniform distribution within [-limit, limit], with limit = sqrt(3 * scale / n).
Parameters:
config (Object)
scale (number) Scaling factor (positive float).
mode ('fanIn'|'fanOut'|'fanAvg') Fanning mode for inputs and outputs.
distribution ('normal'|'uniform'|'truncatedNormal') Probabilistic distribution of the values.
seed (number) Random number generator seed.
Returns: tf.initializers.Initializer
tf.initializers.zeros () functionSource
Initializer that generates tensors initialized to 0.

Returns: Zeros
Regularizers
Regularizers can be attached to various components of a Layer to add a 'scoring' function to help drive weights, or other trainable values, away from excessively large values. They're typically used to promote a notion that a 'simpler' model is better than a complicated model, assuming equal performance.

Regularizers /
tf.regularizers.l1 (config?) functionSource
Regularizer for L1 regularization.

Adds a term to the loss to penalize large weights: loss += sum(l1 * abs(x))

Parameters:
config (Object) Optional
l1 (number) L1 regularization rate. Defaults to 0.01.
Returns: Regularizer
tf.regularizers.l1l2 (config?) functionSource
Regularizer for L1 and L2 regularization.

Adds a term to the loss to penalize large weights: loss += sum(l1 * abs(x)) + sum(l2 * x^2)

Parameters:
config (Object) Optional
l1 (number) L1 regularization rate. Defaults to 0.01.
l2 (number) L2 regularization rate. Defaults to 0.01.
Returns: Regularizer
tf.regularizers.l2 (config?) functionSource
Regularizer for L2 regularization.

Adds a term to the loss to penalize large weights: loss += sum(l2 * x^2)

Parameters:
config (Object) Optional
l2 (number) L2 regularization rate. Defaults to 0.01.
Returns: Regularizer
Data
TensorFlow.js Data provides simple APIs to load and parse data from disk or over the web in a variety of formats, and to prepare that data for use in machine learning models (e.g. via operations like filter, map, shuffle, and batch).

Data / Creation
tf.data.array (items) functionSource
Create a Dataset from an array of elements.

Create a Dataset from an array of objects:

const a = tf.data.array([{'item': 1}, {'item': 2}, {'item': 3}]);
await a.forEachAsync(e => console.log(e));
EditRun
Create a Dataset from an array of numbers:

const a = tf.data.array([4, 5, 6]);
await a.forEachAsync(e => console.log(e));
EditRun
Parameters:
items (tf.void|number|string|TypedArray|tf.Tensor|tf.Tensor[]|{[key: string]:tf.Tensor|number|string}[]) An array of elements that will be parsed as items in a dataset.
Returns: tf.data.Dataset
tf.data.csv (source, csvConfig?) functionSource
Create a CSVDataset by reading and decoding CSV file(s) from provided URL or local path if it's in Node environment.

Note: If isLabel in columnConfigs is true for at least one column, the element in returned CSVDataset will be an object of {xs:features, ys:labels}: xs is a dict of features key/value pairs, ys is a dict of labels key/value pairs. If no column is marked as label, returns a dict of features only.

const csvUrl =
'https://storage.googleapis.com/tfjs-examples/multivariate-linear-regression/data/boston-housing-train.csv';

async function run() {
   // We want to predict the column "medv", which represents a median value of
   // a home (in $1000s), so we mark it as a label.
   const csvDataset = tf.data.csv(
     csvUrl, {
       columnConfigs: {
         medv: {
           isLabel: true
         }
       }
     });

   // Number of features is the number of column names minus one for the label
   // column.
   const numOfFeatures = (await csvDataset.columnNames()).length - 1;

   // Prepare the Dataset for training.
   const flattenedDataset =
     csvDataset
     .map(({xs, ys}) =>
       {
         // Convert xs(features) and ys(labels) from object form (keyed by
         // column name) to array form.
         return {xs:Object.values(xs), ys:Object.values(ys)};
       })
     .batch(10);

   // Define the model.
   const model = tf.sequential();
   model.add(tf.layers.dense({
     inputShape: [numOfFeatures],
     units: 1
   }));
   model.compile({
     optimizer: tf.train.sgd(0.000001),
     loss: 'meanSquaredError'
   });

   // Fit the model using the prepared Dataset
   return model.fitDataset(flattenedDataset, {
     epochs: 10,
     callbacks: {
       onEpochEnd: async (epoch, logs) => {
         console.log(epoch + ':' + logs.loss);
       }
     }
   });
}

await run();
EditRun
Parameters:
source (RequestInfo) URL or local path to get CSV file. If it's a local path, it must have prefix file:// and it only works in node environment.
csvConfig (Object) (Optional) A CSVConfig object that contains configurations of reading and decoding from CSV file(s). Optional
hasHeader (boolean) A boolean value that indicates whether the first row of provided CSV file is a header line with column names, and should not be included in the data.
columnNames (string[]) A list of strings that corresponds to the CSV column names, in order. If provided, it ignores the column names inferred from the header row. If not provided, infers the column names from the first row of the records. If hasHeader is false and columnNames is not provided, this method will throw an error.
columnConfigs ({[key: string]: ColumnConfig}) A dictionary whose key is column names, value is an object stating if this column is required, column's data type, default value, and if this column is label. If provided, keys must correspond to names provided in columnNames or inferred from the file header lines. If any column is marked as label, the .csv() API will return an array of two items: the first item is a dict of features key/value pairs, the second item is a dict of labels key/value pairs. If no column is marked as label returns a dict of features only.
Has the following fields:

required If value in this column is required. If set to true, throw an error when it finds an empty value.

dtype Data type of this column. Could be int32, float32, bool, or string.

default Default value of this column.

isLabel Whether this column is label instead of features. If isLabel is true for at least one column, the element in returned CSVDataset will be an object of {xs: features, ys: labels}: xs is a dict of features key/value pairs, ys is a dict of labels key/value pairs. If no column is marked as label, returns a dict of features only.

configuredColumnsOnly (boolean) If true, only columns provided in columnConfigs will be parsed and provided during iteration.
delimiter (string) The string used to parse each line of the input file.
delimWhitespace (boolean) If true, delimiter field should be null. Parsing delimiter is whitespace and treat continuous multiple whitespace as one delimiter.
Returns: tf.data.CSVDataset
tf.data.generator (generator) functionSource
Create a Dataset that produces each element from provided JavaScript generator, which is a function that returns a (potentially async) iterator.

For more information on iterators and generators, see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators . For the iterator protocol, see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols .

Example of creating a dataset from an iterator factory:

function makeIterator() {
   const numElements = 10;
   let index = 0;

   const iterator = {
     next: () => {
       let result;
       if (index < numElements) {
         result = {value: index, done: false};
         index++;
         return result;
       }
       return {value: index, done: true};
     }
   };
   return iterator;
}
const ds = tf.data.generator(makeIterator);
await ds.forEachAsync(e => console.log(e));
EditRun
Example of creating a dataset from a generator:

function* dataGenerator() {
   const numElements = 10;
   let index = 0;
   while (index < numElements) {
     const x = index;
     index++;
     yield x;
   }
}

const ds = tf.data.generator(dataGenerator);
await ds.forEachAsync(e => console.log(e));
EditRun
Parameters:
generator (() => Iterator | Promise<Iterator<void|number|string|TypedArray|tf.Tensor|tf.Tensor[]|{[key: string]:tf.Tensor|number|string}>> | AsyncIterator<void|number|string|TypedArray|tf.Tensor|tf.Tensor[]|{[key: string]:tf.Tensor|number|string}>) A JavaScript function that returns a (potentially async) JavaScript iterator.
Returns: tf.data.Dataset
tf.data.microphone (microphoneConfig?) functionSource
Create an iterator that generates frequency-domain spectrogram Tensors from microphone audio stream with browser's native FFT. This API only works in browser environment when the device has microphone.

Note: this code snippet only works when the device has a microphone. It will request permission to open the microphone when running.

const mic = await tf.data.microphone({
   fftSize: 1024,
   columnTruncateLength: 232,
   numFramesPerSpectrogram: 43,
   sampleRateHz:44100,
   includeSpectrogram: true,
   includeWaveform: true
});
const audioData = await mic.capture();
const spectrogramTensor = audioData.spectrogram;
spectrogramTensor.print();
const waveformTensor = audioData.waveform;
waveformTensor.print();
mic.stop();
EditRun
Parameters:
microphoneConfig (Object) A MicrophoneConfig object that contains configurations of reading audio data from microphone. Optional
sampleRateHz (44100|48000)
fftSize (number)
columnTruncateLength (number)
numFramesPerSpectrogram (number)
audioTrackConstraints (MediaTrackConstraints)
smoothingTimeConstant (number)
includeSpectrogram (boolean)
includeWaveform (boolean)
Returns: Promise<MicrophoneIterator>
tf.data.webcam (webcamVideoElement?, webcamConfig?) functionSource
Create an iterator that generates Tensors from webcam video stream. This API only works in Browser environment when the device has webcam.

Note: this code snippet only works when the device has a webcam. It will request permission to open the webcam when running.

const videoElement = document.createElement('video');
videoElement.width = 100;
videoElement.height = 100;
const cam = await tf.data.webcam(videoElement);
const img = await cam.capture();
img.print();
cam.stop();
EditRun
Parameters:
webcamVideoElement (HTMLVideoElement) A HTMLVideoElement used to play video from webcam. If this element is not provided, a hidden HTMLVideoElement will be created. In that case, resizeWidth and resizeHeight must be provided to set the generated tensor shape. Optional
webcamConfig (Object) A WebcamConfig object that contains configurations of reading and manipulating data from webcam video stream. Optional
facingMode ('user'|'environment') A string specifying which camera to use on device. If the value is 'user', it will use front camera. If the value is 'environment', it will use rear camera.
deviceId (string) A string used to request a specific camera. The deviceId can be obtained by calling mediaDevices.enumerateDevices().
resizeWidth (number) Specifies the width of the output tensor. The actual width of the HTMLVideoElement (if provided) can be different and the final image will be resized to match resizeWidth.
resizeHeight (number) Specifies the height of the output tensor. The actual height of the HTMLVideoElement (if provided) can be different and the final image will be resized to match resizeHeight.
centerCrop (boolean) A boolean value that indicates whether to crop the video frame from center. If true, resizeWidth and resizeHeight must be specified; then an image of size [resizeWidth, resizeHeight] is taken from the center of the frame without scaling. If false, the entire image is returned (perhaps scaled to fit in [resizeWidth, resizeHeight], if those are provided).
Returns: Promise<WebcamIterator>
Data / Operations
tf.data.zip (datasets) functionSource
Create a Dataset by zipping together an array, dict, or nested structure of Datasets (and perhaps additional constants). The underlying datasets must provide elements in a consistent order such that they correspond.

The number of elements in the resulting dataset is the same as the size of the smallest dataset in datasets.

The nested structure of the datasets argument determines the structure of elements in the resulting iterator.

Note this means that, given an array of two datasets that produce dict elements, the result is a dataset that produces elements that are arrays of two dicts:

Zip an array of datasets:

console.log('Zip two datasets of objects:');
const ds1 = tf.data.array([{a: 1}, {a: 2}, {a: 3}]);
const ds2 = tf.data.array([{b: 4}, {b: 5}, {b: 6}]);
const ds3 = tf.data.zip([ds1, ds2]);
await ds3.forEachAsync(e => console.log(JSON.stringify(e)));

// If the goal is to merge the dicts in order to produce elements like
// {a: ..., b: ...}, this requires a second step such as:
console.log('Merge the objects:');
const ds4 = ds3.map(x => {return {a: x[0].a, b: x[1].b}});
await ds4.forEachAsync(e => console.log(e));
EditRun
Zip a dict of datasets:

const a = tf.data.array([{a: 1}, {a: 2}, {a: 3}]);
const b = tf.data.array([{b: 4}, {b: 5}, {b: 6}]);
const c = tf.data.zip({c: a, d: b});
await c.forEachAsync(e => console.log(JSON.stringify(e)));
EditRun
Parameters:
datasets (DatasetContainer)
Returns: tf.data.Dataset
Data / Classes
tf.data.CSVDataset extends tf.data.Dataset classSource
Represents a potentially large collection of delimited text records.

The produced TensorContainers each contain one key-value pair for every column of the table. When a field is empty in the incoming data, the resulting value is undefined, or throw error if it is required. Values that can be parsed as numbers are emitted as type number, other values are parsed as string.

The results are not batched.

columnNames () methodSource
Returns column names of the csv dataset. If configuredColumnsOnly is true, return column names in columnConfigs. If configuredColumnsOnly is false and columnNames is provided, columnNames. If configuredColumnsOnly is false and columnNames is not provided, return all column names parsed from the csv file. For example usage please go to tf.data.csv().

Returns: Promise<string[]>
tf.data.Dataset classSource
Represents a potentially large list of independent data elements (typically 'samples' or 'examples').

A 'data example' may be a primitive, an array, a map from string keys to values, or any nested structure of these.

A Dataset represents an ordered collection of elements, together with a chain of transformations to be performed on those elements. Each transformation is a method of Dataset that returns another Dataset, so these may be chained, e.g. const processedDataset = rawDataset.filter(...).map(...).batch(...).

Data loading and transformation is done in a lazy, streaming fashion. The dataset may be iterated over multiple times; each iteration starts the data loading anew and recapitulates the transformations.

A Dataset is typically processed as a stream of unbatched examples -- i.e., its transformations are applied one example at a time. Batching produces a new Dataset where each element is a batch. Batching should usually come last in a pipeline, because data transformations are easier to express on a per-example basis than on a per-batch basis.

The following code examples are calling await dataset.forEachAsync(...) to iterate once over the entire dataset in order to print out the data.

batch (batchSize, smallLastBatch?) methodSource
Groups elements into batches.

It is assumed that each of the incoming dataset elements has the same structure -- i.e. the same set of keys at each location in an object hierarchy. For each key, the resulting Dataset provides a batched element collecting all of the incoming values for that key.

Incoming primitives are grouped into a 1-D Tensor. Incoming Tensors are grouped into a new Tensor where the 0th axis is the batch dimension. Incoming arrays are converted to Tensor and then batched. A nested array is interpreted as an n-D Tensor, so the batched result has n+1 dimensions. An array that cannot be converted to Tensor produces an error.

If an array should not be batched as a unit, it should first be converted to an object with integer keys.

Here are a few examples:

Batch a dataset of numbers:

const a = tf.data.array([1, 2, 3, 4, 5, 6, 7, 8]).batch(4);
await a.forEachAsync(e => e.print());
EditRun
Batch a dataset of arrays:

const b = tf.data.array([[1], [2], [3], [4], [5], [6], [7], [8]]).batch(4);
await b.forEachAsync(e => e.print());
EditRun
Batch a dataset of objects:

const c = tf.data.array([{a: 1, b: 11}, {a: 2, b: 12}, {a: 3, b: 13},
   {a: 4, b: 14}, {a: 5, b: 15}, {a: 6, b: 16}, {a: 7, b: 17},
   {a: 8, b: 18}]).batch(4);
await c.forEachAsync(e => {
   console.log('{');
   for(var key in e) {
     console.log(key+':');
     e[key].print();
   }
   console.log('}');
})
EditRun
Parameters:
batchSize (number) The number of elements desired per batch.
smallLastBatch (boolean) Whether to emit the final batch when it has fewer than batchSize elements. Default true. Optional
Returns: tf.data.Dataset
concatenate (dataset) methodSource
Concatenates this Dataset with another.

const a = tf.data.array([1, 2, 3]);
const b = tf.data.array([4, 5, 6]);
const c = a.concatenate(b);
await c.forEachAsync(e => console.log(e));
EditRun
Parameters:
dataset (tf.data.Dataset) A Dataset to be concatenated onto this one.
Returns: tf.data.Dataset
filter (predicate) methodSource
Filters this dataset according to predicate.

const a = tf.data.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
   .filter(x => x%2 === 0);
await a.forEachAsync(e => console.log(e));
EditRun
Parameters:
predicate ((value: T) => boolean) A function mapping a dataset element to a boolean or a Promise for one.
Returns: tf.data.Dataset
forEachAsync (f) methodSource
Apply a function to every element of the dataset.

After the function is applied to a dataset element, any Tensors contained within that element are disposed.

const a = tf.data.array([1, 2, 3]);
await a.forEachAsync(e => console.log(e));
EditRun
Parameters:
f ((input: T) => void) A function to apply to each dataset element.
Returns: Promise<void>
map (transform) methodSource
Maps this dataset through a 1-to-1 transform.

const a = tf.data.array([1, 2, 3]).map(x => x*x);
await a.forEachAsync(e => console.log(e));
EditRun
Parameters:
transform ((value: T) => tf.void|number|string|TypedArray|tf.Tensor|tf.Tensor[]|{[key: string]:tf.Tensor|number|string}) A function mapping a dataset element to a transformed dataset element.
Returns: tf.data.Dataset
mapAsync (transform) methodSource
Maps this dataset through an async 1-to-1 transform.

const a =
  tf.data.array([1, 2, 3]).mapAsync(x => new Promise(function(resolve){
    setTimeout(() => {
      resolve(x * x);
    }, Math.random()*1000 + 500);
  }));
console.log(await a.toArray());
EditRun
Parameters:
transform ((value: T) => Promise<tf.void|number|string|TypedArray|tf.Tensor|tf.Tensor[]|{[key: string]:tf.Tensor|number|string}>) A function mapping a dataset element to a Promise for a transformed dataset element. This transform is responsible for disposing any intermediate Tensors, i.e. by wrapping its computation in tf.tidy(); that cannot be automated here (as it is in the synchronous map() case).
Returns: tf.data.Dataset
prefetch (bufferSize) methodSource
Creates a Dataset that prefetches elements from this dataset.

Parameters:
bufferSize (number) : An integer specifying the number of elements to be prefetched.
Returns: tf.data.Dataset
repeat (count?) methodSource
Repeats this dataset count times.

NOTE: If this dataset is a function of global state (e.g. a random number generator), then different repetitions may produce different elements.

const a = tf.data.array([1, 2, 3]).repeat(3);
await a.forEachAsync(e => console.log(e));
EditRun
Parameters:
count (number) : (Optional) An integer, representing the number of times the dataset should be repeated. The default behavior (if count is undefined or negative) is for the dataset be repeated indefinitely. Optional
Returns: tf.data.Dataset
skip (count) methodSource
Creates a Dataset that skips count initial elements from this dataset.

const a = tf.data.array([1, 2, 3, 4, 5, 6]).skip(3);
await a.forEachAsync(e => console.log(e));
EditRun
Parameters:
count (number) : The number of elements of this dataset that should be skipped to form the new dataset. If count is greater than the size of this dataset, the new dataset will contain no elements. If count is undefined or negative, skips the entire dataset.
Returns: tf.data.Dataset
shuffle (bufferSize, seed?, reshuffleEachIteration?) methodSource
Pseudorandomly shuffles the elements of this dataset. This is done in a streaming manner, by sampling from a given number of prefetched elements.

const a = tf.data.array([1, 2, 3, 4, 5, 6]).shuffle(3);
await a.forEachAsync(e => console.log(e));
EditRun
Parameters:
bufferSize (number) : An integer specifying the number of elements from this dataset from which the new dataset will sample.
seed (string) : (Optional) An integer specifying the random seed that will be used to create the distribution. Optional
reshuffleEachIteration (boolean) : (Optional) A boolean, which if true indicates that the dataset should be pseudorandomly reshuffled each time it is iterated over. If false, elements will be returned in the same shuffled order on each iteration. (Defaults to true.) Optional
Returns: tf.data.Dataset
take (count) methodSource
Creates a Dataset with at most count initial elements from this dataset.

const a = tf.data.array([1, 2, 3, 4, 5, 6]).take(3);
await a.forEachAsync(e => console.log(e));
EditRun
Parameters:
count (number) : The number of elements of this dataset that should be taken to form the new dataset. If count is undefined or negative, or if count is greater than the size of this dataset, the new dataset will contain all elements of this dataset.
Returns: tf.data.Dataset
toArray () methodSource
Collect all elements of this dataset into an array.

Obviously this will succeed only for small datasets that fit in memory. Useful for testing and generally should be avoided if possible.

const a = tf.data.array([1, 2, 3, 4, 5, 6]);
console.log(await a.toArray());
EditRun
Returns: Promise<T[]>
Visualization
tfjs-vis is a companion library for TensorFlow.js that provides in-browser visualization capabilities for training and understanding models. API docs for tfjs-vis are available here

Util
Util /
tf.util.assert (expr, msg) functionSource
Asserts that the expression is true. Otherwise throws an error with the provided message.

const x = 2;
tf.util.assert(x === 2, 'x is not 2');
EditRun
Parameters:
expr (boolean) The expression to assert (as a boolean).
msg (() => string) A function that returns the message to report when throwing an error. We use a function for performance reasons.
Returns: void
tf.util.createShuffledIndices (n) functionSource
Creates a new array with randomized indices to a given quantity.

const randomTen = tf.util.createShuffledIndices(10);
console.log(randomTen);
EditRun
Parameters:
n (number)
Returns: Uint32Array
tf.decodeString (bytes, encoding?) functionSource
Decodes the provided bytes into a string using the provided encoding scheme.

Parameters:
bytes (Uint8Array) The bytes to decode.
encoding (string) The encoding scheme. Defaults to utf-8. Optional
Returns: string
tf.encodeString (s, encoding?) functionSource
Encodes the provided string into bytes using the provided encoding scheme.

Parameters:
s (string) The string to encode.
encoding (string) The encoding scheme. Defaults to utf-8. Optional
Returns: Uint8Array
tf.fetch (path, requestInits?) functionSource
Returns a platform-specific implementation of fetch.

If fetch is defined on the global object (window, process, etc.), tf.util.fetch returns that function.

If not, tf.util.fetch returns a platform-specific solution.

const resource = await tf.util.fetch('https://cdn.jsdelivr.net/npm/@tensorflow/tfjs');
// handle response
EditRun
Parameters:
path (string)
requestInits (RequestInit) Optional
Returns: Promise<Response>
tf.util.flatten (arr, result?, skipTypedArray?) functionSource
Flattens an arbitrarily nested array.

const a = [[1, 2], [3, 4], [5, [6, [7]]]];
const flat = tf.util.flatten(a);
console.log(flat);
EditRun
Parameters:
arr (number|boolean|string|Promise<number>|TypedArray|RecursiveArray|TypedArray>) The nested array to flatten.
result (number|boolean|string|Promise<number>|TypedArray[]) The destination array which holds the elements. Optional
skipTypedArray (boolean) If true, avoids flattening the typed arrays. Defaults to false. Optional
Returns: number|boolean|string|Promise<number>|TypedArray[]
tf.util.now () functionSource
Returns the current high-resolution time in milliseconds relative to an arbitrary time in the past. It works across different platforms (node.js, browsers).

console.log(tf.util.now());
EditRun
Returns: number
tf.util.shuffle (array) functionSource
Shuffles the array in-place using Fisher-Yates algorithm.

const a = [1, 2, 3, 4, 5];
tf.util.shuffle(a);
console.log(a);
EditRun
Parameters:
array (tf.any()[]|Uint32Array|Int32Array| Float32Array) The array to shuffle in-place.
Returns: void
tf.util.shuffleCombo (array, array2) functionSource
Shuffles two arrays in-place the same way using Fisher-Yates algorithm.

const a = [1,2,3,4,5];
const b = [11,22,33,44,55];
tf.util.shuffleCombo(a, b);
console.log(a, b);
EditRun
Parameters:
array (tf.any()[]|Uint32Array|Int32Array|Float32Array) The first array to shuffle in-place.
array2 (tf.any()[]|Uint32Array|Int32Array|Float32Array) The second array to shuffle in-place with the same permutation as the first array.
Returns: void
tf.util.sizeFromShape (shape) functionSource
Returns the size (number of elements) of the tensor given its shape.

const shape = [3, 4, 2];
const size = tf.util.sizeFromShape(shape);
console.log(size);
EditRun
Parameters:
shape (number[])
Returns: number
Backends
Backends /
tf.backend () functionSource
Gets the current backend. If no backends have been initialized, this will attempt to initialize the best backend. Will throw an error if the highest priority backend has async initialization, in which case you should call 'await tf.ready()' before running other code.

Returns: KernelBackend
tf.getBackend () functionSource
Returns the current backend name (cpu, webgl, etc). The backend is responsible for creating tensors and executing operations on those tensors.

Returns: string
tf.ready () functionSource
Returns a promise that resolves when the currently selected backend (or the highest priority one) has initialized. Await this promise when you are using a backend that has async initialization.

Returns: Promise<void>
tf.registerBackend (name, factory, priority?) functionSource
Registers a global backend. The registration should happen when importing a module file (e.g. when importing backend_webgl.ts), and is used for modular builds (e.g. custom tfjs bundle with only webgl support).

Parameters:
name (string)
factory (() => KernelBackend | Promise<KernelBackend>) The backend factory function. When called, it should return a backend instance, or a promise of an instance.
priority (number) The priority of the backend (higher = more important). In case multiple backends are registered, the priority is used to find the best backend. Defaults to 1. Optional
Returns: boolean
tf.removeBackend (name) functionSource
Removes a backend and the registered factory.

Parameters:
name (string)
Returns: void
tf.setBackend (backendName) functionSource
Sets the backend (cpu, webgl, wasm, etc) responsible for creating tensors and executing operations on those tensors. Returns a promise that resolves to a boolean if the backend initialization was successful.

Note this disposes the current backend, if any, as well as any tensors associated with it. A new backend is initialized, even if it is of the same type as the previous one.

Parameters:
backendName (string) The name of the backend. Currently supports 'webgl'|'cpu' in the browser, 'tensorflow' under node.js (requires tfjs-node), and 'wasm' (requires tfjs-backend-wasm).
Returns: Promise<boolean>
Browser
Browser /
tf.browser.draw (image, canvas, options?) functionSource
Draws a tf.Tensor to a canvas.

When the dtype of the input is 'float32', we assume values in the range [0-1]. Otherwise, when input is 'int32', we assume values in the range [0-255].

Parameters:
image (tf.Tensor2D|tf.Tensor3D|TypedArray|Array) The tensor to draw on the canvas. Must match one of these shapes:
Rank-2 with shape [height, width]: Drawn as grayscale.
Rank-3 with shape [height, width, 1]: Drawn as grayscale.
Rank-3 with shape [height, width, 3]: Drawn as RGB with alpha set in imageOptions (defaults to 1, which is opaque).
Rank-3 with shape [height, width, 4]: Drawn as RGBA.
canvas (HTMLCanvasElement) The canvas to draw to.
options (Object) The configuration arguments for image to be drawn and the canvas to draw to. Optional
imageOptions (ImageOptions) Optional. An object of options to customize the values of image tensor.
contextOptions (ContextOptions) Optional. An object to configure the context of the canvas to draw to.
Returns: void
tf.browser.fromPixels (pixels, numChannels?) functionSource
Creates a tf.Tensor from an image.

const image = new ImageData(1, 1);
image.data[0] = 100;
image.data[1] = 150;
image.data[2] = 200;
image.data[3] = 255;

tf.browser.fromPixels(image).print();
EditRun
Parameters:
pixels (PixelData|ImageData|HTMLImageElement|HTMLCanvasElement| HTMLVideoElement|ImageBitmap) The input image to construct the tensor from. The supported image types are all 4-channel. You can also pass in an image object with following attributes: {data: Uint8Array; width: number; height: number}
numChannels (number) The number of channels of the output tensor. A numChannels value less than 4 allows you to ignore channels. Defaults to 3 (ignores alpha channel of input image). Optional
Returns: tf.Tensor3D
tf.browser.fromPixelsAsync (pixels, numChannels?) functionSource
Creates a tf.Tensor from an image in async way.

const image = new ImageData(1, 1);
image.data[0] = 100;
image.data[1] = 150;
image.data[2] = 200;
image.data[3] = 255;

(await tf.browser.fromPixelsAsync(image)).print();
EditRun
This API is the async version of fromPixels. The API will first check |WRAP_TO_IMAGEBITMAP| flag, and try to wrap the input to imageBitmap if the flag is set to true.

Parameters:
pixels (PixelData|ImageData|HTMLImageElement|HTMLCanvasElement| HTMLVideoElement|ImageBitmap) The input image to construct the tensor from. The supported image types are all 4-channel. You can also pass in an image object with following attributes: {data: Uint8Array; width: number; height: number}
numChannels (number) The number of channels of the output tensor. A numChannels value less than 4 allows you to ignore channels. Defaults to 3 (ignores alpha channel of input image). Optional
Returns: Promise<tf.Tensor>
tf.browser.toPixels (img, canvas?) functionSource
Draws a tf.Tensor of pixel values to a byte array or optionally a canvas.

When the dtype of the input is 'float32', we assume values in the range [0-1]. Otherwise, when input is 'int32', we assume values in the range [0-255].

Returns a promise that resolves when the canvas has been drawn to.

Parameters:
img (tf.Tensor2D|tf.Tensor3D|TypedArray|Array) A rank-2 tensor with shape [height, width], or a rank-3 tensor of shape [height, width, numChannels]. If rank-2, draws grayscale. If rank-3, must have depth of 1, 3 or 4. When depth of 1, draws grayscale. When depth of 3, we draw with the first three components of the depth dimension corresponding to r, g, b and alpha = 1. When depth of 4, all four components of the depth dimension correspond to r, g, b, a.
canvas (HTMLCanvasElement) The canvas to draw to. Optional
Returns: Promise<Uint8ClampedArray>
Metrics
Metrics /
tf.metrics.binaryAccuracy (yTrue, yPred) functionSource
Binary accuracy metric function.

yTrue and yPred can have 0-1 values. Example:

const x = tf.tensor2d([[1, 1, 1, 1], [0, 0, 0, 0]], [2, 4]);
const y = tf.tensor2d([[1, 0, 1, 0], [0, 0, 0, 1]], [2, 4]);
const accuracy = tf.metrics.binaryAccuracy(x, y);
accuracy.print();
EditRun
yTrue and yPred can also have floating-number values between 0 and 1, in which case the values will be thresholded at 0.5 to yield 0-1 values (i.e., a value >= 0.5 and <= 1.0 is interpreted as 1).

Example:

const x = tf.tensor1d([1, 1, 1, 1, 0, 0, 0, 0]);
const y = tf.tensor1d([0.2, 0.4, 0.6, 0.8, 0.2, 0.3, 0.4, 0.7]);
const accuracy = tf.metrics.binaryAccuracy(x, y);
accuracy.print();
EditRun
Parameters:
yTrue (tf.Tensor) Binary Tensor of truth.
yPred (tf.Tensor) Binary Tensor of prediction.
Returns: tf.Tensor
tf.metrics.binaryCrossentropy (yTrue, yPred) functionSource
Binary crossentropy metric function.

Example:

const x = tf.tensor2d([[0], [1], [1], [1]]);
const y = tf.tensor2d([[0], [0], [0.5], [1]]);
const crossentropy = tf.metrics.binaryCrossentropy(x, y);
crossentropy.print();
EditRun
Parameters:
yTrue (tf.Tensor) Binary Tensor of truth.
yPred (tf.Tensor) Binary Tensor of prediction, probabilities for the 1 case.
Returns: tf.Tensor
tf.metrics.categoricalAccuracy (yTrue, yPred) functionSource
Categorical accuracy metric function.

Example:

const x = tf.tensor2d([[0, 0, 0, 1], [0, 0, 0, 1]]);
const y = tf.tensor2d([[0.1, 0.8, 0.05, 0.05], [0.1, 0.05, 0.05, 0.8]]);
const accuracy = tf.metrics.categoricalAccuracy(x, y);
accuracy.print();
EditRun
Parameters:
yTrue (tf.Tensor) Binary Tensor of truth: one-hot encoding of categories.
yPred (tf.Tensor) Binary Tensor of prediction: probabilities or logits for the same categories as in yTrue.
Returns: tf.Tensor
tf.metrics.categoricalCrossentropy (yTrue, yPred) functionSource
Categorical crossentropy between an output tensor and a target tensor.

Parameters:
yTrue (tf.Tensor)
yPred (tf.Tensor)
Returns: tf.Tensor
tf.metrics.cosineProximity (yTrue, yPred) functionSource
Loss or metric function: Cosine proximity.

Mathematically, cosine proximity is defined as: -sum(l2Normalize(yTrue) * l2Normalize(yPred)), wherein l2Normalize() normalizes the L2 norm of the input to 1 and * represents element-wise multiplication.

const yTrue = tf.tensor2d([[1, 0], [1, 0]]);
const yPred = tf.tensor2d([[1 / Math.sqrt(2), 1 / Math.sqrt(2)], [0, 1]]);
const proximity = tf.metrics.cosineProximity(yTrue, yPred);
proximity.print();
EditRun
Parameters:
yTrue (tf.Tensor) Truth Tensor.
yPred (tf.Tensor) Prediction Tensor.
Returns: tf.Tensor
tf.metrics.meanAbsoluteError (yTrue, yPred) functionSource
Loss or metric function: Mean absolute error.

Mathematically, mean absolute error is defined as: mean(abs(yPred - yTrue)), wherein the mean is applied over feature dimensions.

const yTrue = tf.tensor2d([[0, 1], [0, 0], [2, 3]]);
const yPred = tf.tensor2d([[0, 1], [0, 1], [-2, -3]]);
const mse = tf.metrics.meanAbsoluteError(yTrue, yPred);
mse.print();
EditRun
Parameters:
yTrue (tf.Tensor) Truth Tensor.
yPred (tf.Tensor) Prediction Tensor.
Returns: tf.Tensor
tf.metrics.meanAbsolutePercentageError (yTrue, yPred) functionSource
Loss or metric function: Mean absolute percentage error.

const yTrue = tf.tensor2d([[0, 1], [10, 20]]);
const yPred = tf.tensor2d([[0, 1], [11, 24]]);
const mse = tf.metrics.meanAbsolutePercentageError(yTrue, yPred);
mse.print();
EditRun
Aliases: tf.metrics.MAPE, tf.metrics.mape.

Parameters:
yTrue (tf.Tensor) Truth Tensor.
yPred (tf.Tensor) Prediction Tensor.
Returns: tf.Tensor
tf.metrics.meanSquaredError (yTrue, yPred) functionSource
Loss or metric function: Mean squared error.

const yTrue = tf.tensor2d([[0, 1], [3, 4]]);
const yPred = tf.tensor2d([[0, 1], [-3, -4]]);
const mse = tf.metrics.meanSquaredError(yTrue, yPred);
mse.print();
EditRun
Aliases: tf.metrics.MSE, tf.metrics.mse.

Parameters:
yTrue (tf.Tensor) Truth Tensor.
yPred (tf.Tensor) Prediction Tensor.
Returns: tf.Tensor
tf.metrics.precision (yTrue, yPred) functionSource
Computes the precision of the predictions with respect to the labels.

Example:

const x = tf.tensor2d(
    [
      [0, 0, 0, 1],
      [0, 1, 0, 0],
      [0, 0, 0, 1],
      [1, 0, 0, 0],
      [0, 0, 1, 0]
    ]
);

const y = tf.tensor2d(
    [
      [0, 0, 1, 0],
      [0, 1, 0, 0],
      [0, 0, 0, 1],
      [0, 1, 0, 0],
      [0, 1, 0, 0]
    ]
);

const precision = tf.metrics.precision(x, y);
precision.print();
EditRun
Parameters:
yTrue (tf.Tensor) The ground truth values. Expected to contain only 0-1 values.
yPred (tf.Tensor) The predicted values. Expected to contain only 0-1 values.
Returns: tf.Tensor
tf.metrics.r2Score (yTrue, yPred) functionSource
Computes R2 score.

const yTrue = tf.tensor2d([[0, 1], [3, 4]]);
const yPred = tf.tensor2d([[0, 1], [-3, -4]]);
const r2Score = tf.metrics.r2Score(yTrue, yPred);
r2Score.print();
EditRun
Parameters:
yTrue (tf.Tensor) Truth Tensor.
yPred (tf.Tensor) Prediction Tensor.
Returns: tf.Tensor
tf.metrics.recall (yTrue, yPred) functionSource
Computes the recall of the predictions with respect to the labels.

Example:

const x = tf.tensor2d(
    [
      [0, 0, 0, 1],
      [0, 1, 0, 0],
      [0, 0, 0, 1],
      [1, 0, 0, 0],
      [0, 0, 1, 0]
    ]
);

const y = tf.tensor2d(
    [
      [0, 0, 1, 0],
      [0, 1, 0, 0],
      [0, 0, 0, 1],
      [0, 1, 0, 0],
      [0, 1, 0, 0]
    ]
);

const recall = tf.metrics.recall(x, y);
recall.print();
EditRun
Parameters:
yTrue (tf.Tensor) The ground truth values. Expected to contain only 0-1 values.
yPred (tf.Tensor) The predicted values. Expected to contain only 0-1 values.
Returns: tf.Tensor
tf.metrics.sparseCategoricalAccuracy (yTrue, yPred) functionSource
Sparse categorical accuracy metric function.

Example:


const yTrue = tf.tensor1d([1, 1, 2, 2, 0]);
const yPred = tf.tensor2d(
      [[0, 1, 0], [1, 0, 0], [0, 0.4, 0.6], [0, 0.6, 0.4], [0.7, 0.3, 0]]);
const crossentropy = tf.metrics.sparseCategoricalAccuracy(yTrue, yPred);
crossentropy.print();
EditRun
Parameters:
yTrue (tf.Tensor) True labels: indices.
yPred (tf.Tensor) Predicted probabilities or logits.
Returns: tf.Tensor
Callbacks
Callbacks /
tf.callbacks.earlyStopping (args?) functionSource
Factory function for a Callback that stops training when a monitored quantity has stopped improving.

Early stopping is a type of regularization, and protects model against overfitting.

The following example based on fake data illustrates how this callback can be used during tf.LayersModel.fit():

const model = tf.sequential();
model.add(tf.layers.dense({
   units: 3,
   activation: 'softmax',
   kernelInitializer: 'ones',
   inputShape: [2]
}));
const xs = tf.tensor2d([1, 2, 3, 4], [2, 2]);
const ys = tf.tensor2d([[1, 0, 0], [0, 1, 0]], [2, 3]);
const xsVal = tf.tensor2d([4, 3, 2, 1], [2, 2]);
const ysVal = tf.tensor2d([[0, 0, 1], [0, 1, 0]], [2, 3]);
model.compile(
     {loss: 'categoricalCrossentropy', optimizer: 'sgd', metrics: ['acc']});

// Without the EarlyStopping callback, the val_acc value would be:
//   0.5, 0.5, 0.5, 0.5, ...
// With val_acc being monitored, training should stop after the 2nd epoch.
const history = await model.fit(xs, ys, {
   epochs: 10,
   validationData: [xsVal, ysVal],
   callbacks: tf.callbacks.earlyStopping({monitor: 'val_acc'})
});

// Expect to see a length-2 array.
console.log(history.history.val_acc);
EditRun
Parameters:
args (Object) Optional
monitor (string) Quantity to be monitored.
Defaults to 'val_loss'.

minDelta (number) Minimum change in the monitored quantity to qualify as improvement, i.e., an absolute change of less than minDelta will count as no improvement.
Defaults to 0.

patience (number) Number of epochs with no improvement after which training will be stopped.
Defaults to 0.

verbose (number) Verbosity mode.
mode ('auto'|'min'|'max') Mode: one of 'min', 'max', and 'auto'.
In 'min' mode, training will be stopped when the quantity monitored has stopped decreasing.
In 'max' mode, training will be stopped when the quantity monitored has stopped increasing.
In 'auto' mode, the direction is inferred automatically from the name of the monitored quantity.
Defaults to 'auto'.

baseline (number) Baseline value of the monitored quantity.
If specified, training will be stopped if the model doesn't show improvement over the baseline.

restoreBestWeights (boolean) Whether to restore model weights from the epoch with the best value of the monitored quantity. If False, the model weights obtained at the last step of training are used.
True is not supported yet.

Returns: EarlyStopping